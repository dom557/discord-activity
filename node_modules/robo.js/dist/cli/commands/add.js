import fs from 'node:fs/promises';
import path from 'node:path';
import { color } from '../../core/color.js';
import { loadConfig } from '../../core/config.js';
import { logger } from '../../core/logger.js';
import { Command } from '../utils/cli-handler.js';
import { createRequire } from 'node:module';
import { exec } from '../utils/utils.js';
import { getPackageManager } from '../utils/runtime-utils.js';

const require2 = createRequire(import.meta.url);
const localPrefixes = ["file:", ".", "/", "~", ":"];
const command = new Command("add").description("Adds a plugin to your Robo.").option("-f", "--force", "forcefully install & register packages").option("-s", "--silent", "do not print anything").option("-v", "--verbose", "print more information for debugging").positionalArgs(true).handler(addAction);
var add_default = command;
async function addAction(packages, options) {
  logger({
    enabled: !options.silent,
    level: options.verbose ? "debug" : "info"
  }).info(`Adding ${packages.length} plugin${packages.length === 1 ? "" : "s"}...`);
  logger.debug(`Adding plugins:`, packages);
  logger.debug(`Current working directory:`, process.cwd());
  const startTime = Date.now();
  if (packages.length === 0) {
    logger.error(`No packages specified. Use ${color.bold("robo add <package>")} to add a plugin.`);
    return;
  }
  const config = await loadConfig();
  const pendingRegistration = await Promise.all(
    packages.filter((pkg) => {
      return options.force || !config.plugins?.includes(pkg);
    }).map(async (pkg) => {
      const isLocal = localPrefixes.some((prefix) => {
        return prefix === ":" ? pkg.indexOf(prefix) === 1 : pkg.startsWith(prefix);
      });
      if (isLocal) {
        const packageJsonPath2 = path.join(pkg, "package.json");
        const packageJson2 = JSON.parse(await fs.readFile(packageJsonPath2, "utf-8"));
        return packageJson2.name;
      }
      return pkg;
    })
  );
  logger.debug(`Pending registration add:`, pendingRegistration);
  const packageJsonPath = path.join(process.cwd(), "package.json");
  const packageJson = require2(packageJsonPath);
  const pendingInstall = packages.filter((pkg) => {
    return options.force || !Object.keys(packageJson.dependencies ?? {})?.includes(pkg) && !config.plugins?.find((p) => Array.isArray(p) && p[0] === pkg);
  });
  logger.debug(`Pending installation add:`, pendingInstall);
  if (pendingInstall.length > 0) {
    const packageManager = getPackageManager();
    const command2 = packageManager === "npm" ? "install" : "add";
    logger.debug(`Using package manager:`, packageManager);
    try {
      await exec(`${packageManager} ${command2} ${pendingInstall.join(" ")}`, {
        stdio: options.force ? "inherit" : "ignore"
      });
      logger.debug(`Successfully installed packages!`);
    } catch (error) {
      logger.error(`Failed to install packages:`, error);
      if (!options.force) {
        return;
      }
    }
  }
  await Promise.all(pendingRegistration.map((pkg) => createPluginConfig(pkg, {})));
  logger.info(`Successfully completed in ${Date.now() - startTime}ms`);
}
async function createPluginConfig(pluginName, config) {
  const pluginParts = pluginName.replace(/^@/, "").split("/");
  await fs.mkdir(path.join(process.cwd(), "config", "plugins"), {
    recursive: true
  });
  if (pluginName.startsWith("@")) {
    await fs.mkdir(path.join(process.cwd(), "config", "plugins", pluginParts[0]), {
      recursive: true
    });
  }
  const pluginPath = path.join(process.cwd(), "config", "plugins", ...pluginParts) + ".mjs";
  const pluginConfig = JSON.stringify(config) + "\n";
  logger.debug(`Writing ${pluginName} config to ${pluginPath}...`);
  await fs.writeFile(pluginPath, `export default ${pluginConfig}`);
}

export { addAction, add_default as default };
