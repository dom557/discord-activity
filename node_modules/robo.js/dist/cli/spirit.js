import { isMainThread, parentPort, workerData } from 'node:worker_threads';
import { composeColors, color } from '../core/color.js';
import { logger } from '../core/logger.js';
import { removeInstances } from '../core/state.js';

if (isMainThread) {
  logger.error("Spirit file should never be imported from the main thread!");
  process.exit(1);
}
let isRobo = false;
let stateLoadResolve;
const stateLoad = new Promise((resolve) => {
  stateLoadResolve = resolve;
});
async function run(message) {
  if (message.event === "build") {
    const { buildAction } = await import('./commands/build/index.js');
    const payload = message.payload;
    await buildAction(payload.files, {
      dev: true,
      verbose: message.verbose
    });
    return "exit";
  } else if (message.event === "get-state") {
    const { state } = await import('../core/state.js');
    return removeInstances(state);
  } else if (message.event === "restart") {
    if (!isRobo) {
      return "exit";
    }
    const { Robo } = await import('../core/robo.js');
    Robo.restart();
    return "ok";
  } else if (message.event === "set-state") {
    const { loadState } = await import('../core/state.js');
    loadState(message.state);
    stateLoadResolve();
    return "ok";
  } else if (message.event === "start") {
    const { Robo } = await import('../core/robo.js');
    Robo.start({ stateLoad }).catch((error) => {
      logger.error(error);
      logger.wait(
        `Robo failed to start, please check the logs for more information. Waiting for changes before retrying...`
      );
      process.exit(1);
    });
    isRobo = true;
    return "ok";
  } else if (message.event === "stop") {
    if (!isRobo) {
      return "exit";
    }
    const { Robo } = await import('../core/robo.js');
    Robo.stop();
    return "ok";
  } else {
    throw `Unknown Spirit message event: ${message.event}`;
  }
}
parentPort.on("message", async (message) => {
  if (!isRobo) {
    logger({
      level: message.verbose ? "debug" : "info"
    });
  }
  logger.debug(`Spirit (${composeColors(color.bold, color.cyan)(workerData.spiritId)}) received message:`, message);
  let result;
  try {
    const payload = await run(message);
    result = { event: message.event, payload };
  } catch (error) {
    result = { error, payload: "exit" };
  }
  logger.debug(`Spirit (${composeColors(color.bold, color.cyan)(workerData.spiritId)}) sending response:`, result);
  if (result.payload === "exit") {
    await logger.flush();
  }
  parentPort.postMessage(result);
  if (result.payload === "exit") {
    parentPort.close();
    process.exit();
  }
});
