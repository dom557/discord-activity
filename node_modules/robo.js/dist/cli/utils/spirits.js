import path from 'node:path';
import { Worker } from 'node:worker_threads';
import { __DIRNAME } from './utils.js';
import { logger } from '../../core/logger.js';
import { nameGenerator } from './name-generator.js';
import { composeColors, color } from '../../core/color.js';

class Spirits {
  constructor(size = 3) {
    this.size = size;
    for (let i = 0; i < size; i++) {
      this.newSpirit();
    }
  }
  spirits = {};
  taskQueue = [];
  spiritIndex = 0;
  // There are always a limited number of spirits running at once
  activeSpirits = [];
  nextActiveIndex = 0;
  newSpirit(oldSpirit) {
    const index = oldSpirit ? this.activeSpirits.indexOf(oldSpirit) : this.activeSpirits.length;
    const spiritId = `${this.spiritIndex++}-${nameGenerator()}-${["a", "b", "c"][index]}`;
    const worker = new Worker(path.join(__DIRNAME, "..", "spirit.js"), {
      workerData: { spiritId }
    });
    const newSpirit = { id: spiritId, task: null, worker };
    this.spirits[newSpirit.id] = newSpirit;
    worker.on("message", (message) => {
      const spirit = this.spirits[newSpirit.id];
      logger.debug(`Spirit (${composeColors(color.bold, color.cyan)(spirit.id)}) sent message:`, message);
      if (message.payload === "exit") {
        spirit.task?.resolve(spirit.id);
        spirit.isTerminated = true;
        this.newSpirit(spirit);
        this.tryNextTask();
      } else if (message.payload === "ok") {
        spirit.task?.resolve(spirit.id);
      }
    });
    worker.on("exit", async (exitCode) => {
      logger.debug(`Spirit (${composeColors(color.bold, color.cyan)(spiritId)}) exited with code ${exitCode}`);
      const spirit = this.spirits[newSpirit.id];
      if (spirit.isTerminated) {
        return;
      }
      const retry = spirit.task?.onExit?.(exitCode);
      spirit.isTerminated = true;
      if (retry) {
        this.newSpirit(spirit);
        const value = await this.newTask(spirit.task);
        spirit.task?.onRetry?.(value);
        return;
      }
      if (exitCode === 0) {
        spirit.task?.resolve(spirit.id);
      } else {
        spirit.task?.reject(new Error(`Spirit exited with error code ${exitCode}`));
      }
      this.newSpirit(spirit);
      this.tryNextTask();
    });
    worker.on("error", async (err) => {
      logger.error(err);
      const spirit = this.spirits[newSpirit.id];
      spirit.task?.reject(err);
      spirit.isTerminated = true;
      const retry = spirit.task?.onExit?.(1);
      if (retry) {
        this.newSpirit(spirit);
        const value = await this.newTask(spirit.task);
        spirit.task?.onRetry?.(value);
        return;
      }
      this.newSpirit(spirit);
      this.tryNextTask();
    });
    if (oldSpirit) {
      this.activeSpirits[index] = newSpirit;
    } else {
      this.activeSpirits.push(newSpirit);
    }
  }
  async newTask(task) {
    logger.debug(`New spirit task:`, task);
    return new Promise((resolve, reject) => {
      this.taskQueue.push({
        ...task,
        onRetry: task.onRetry,
        resolve,
        reject
      });
      this.tryNextTask();
    });
  }
  exec(spiritId, message) {
    return new Promise((resolve, reject) => {
      if (!spiritId) {
        logger.debug(`No spirit id provided, skipping exec message:`, message);
        resolve(null);
        return;
      }
      logger.debug(`Executing message on spirit (${composeColors(color.bold, color.cyan)(spiritId)}):`, message);
      const spirit = this.get(spiritId);
      if (!spirit) {
        return reject(new Error(`Spirit ${spiritId} not found`));
      }
      if (spirit.isTerminated) {
        resolve(null);
        return;
      }
      const callback = (response) => {
        if (response.event === message.event) {
          spirit.worker.off("message", callback);
          resolve(response.payload);
        }
      };
      spirit.worker.on("message", callback);
      spirit.worker.postMessage(message);
    });
  }
  get(spiritId) {
    return this.spirits[spiritId];
  }
  off(spiritId, callback) {
    this.get(spiritId)?.worker?.off("message", callback);
  }
  on(spiritId, callback) {
    this.get(spiritId)?.worker?.on("message", callback);
  }
  send(spiritId, message) {
    logger.debug(`Sending message to spirit ${composeColors(color.bold, color.cyan)(spiritId)}:`, message);
    this.get(spiritId).worker.postMessage(message);
  }
  tryNextTask() {
    if (this.taskQueue.length <= 0) {
      logger.debug("No tasks left in queue");
      return;
    }
    const spirit = this.activeSpirits[this.nextActiveIndex];
    if (spirit.task === null) {
      const task = this.taskQueue.shift();
      spirit.task = task;
      const workerTask = { ...task };
      delete workerTask.onExit;
      delete workerTask.onRetry;
      delete workerTask.resolve;
      delete workerTask.reject;
      logger.debug(`Sending task to spirit ${composeColors(color.bold, color.cyan)(spirit.id)}:`, workerTask);
      spirit.worker.postMessage(workerTask);
    }
    this.nextActiveIndex = (this.nextActiveIndex + 1) % this.size;
  }
  async stop(spiritId, force = false) {
    const spirit = this.get(spiritId);
    if (spirit.isTerminated) {
      return Promise.resolve();
    }
    logger.debug(`Stopping spirit ${composeColors(color.bold, color.cyan)(spiritId)} (force: ${force})`);
    if (force || !spirit.task) {
      spirit.worker.terminate();
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      spirit.worker.once("exit", resolve);
      spirit.worker.on("message", (message) => {
        if (message.payload === "exit") {
          spirit.task?.resolve();
          spirit.isTerminated = true;
          resolve();
          this.newSpirit(spirit);
          this.tryNextTask();
        }
      });
      spirit.worker.postMessage({ event: "stop" });
    });
  }
  async stopAll() {
    const promises = Object.values(this.spirits).map((spirit) => this.stop(spirit.id));
    return Promise.all(promises);
  }
}

export { Spirits };
