import fs from 'fs/promises';
import path from 'path';
import { replaceSrcWithBuildInRecord, hasProperties } from './utils.js';
import { logger } from '../../core/logger.js';
import { env } from '../../core/env.js';
import { IS_BUN } from './runtime-utils.js';

const srcDir = path.join(process.cwd(), "src");
let ts;
let transform;
try {
  if (!IS_BUN) {
    const [typescript, swc] = await Promise.all([import('typescript'), import('@swc/core')]);
    ts = typescript.default;
    transform = swc.transform;
  }
} catch {
}
async function traverse(dir, distDir, options, compilerOptions, transform2) {
  const { excludePaths = [], parallel = 20 } = options;
  const isIncremental = options.files?.length > 0;
  let files;
  try {
    if (isIncremental) {
      files = options.files.map((file) => path.join(process.cwd(), file));
      logger.debug(`Incrementally compiling:`, files);
    } else {
      files = await fs.readdir(dir);
    }
  } catch (e) {
    if (hasProperties(e, ["code"]) && e.code === "ENOENT") {
      logger.debug(`Directory ${dir} does not exist, skipping traversal.`);
      return;
    } else {
      throw e;
    }
  }
  const tasks = [];
  for (const file of files) {
    const filePath = isIncremental ? file : path.join(dir, file);
    const relativePath = "/" + path.relative(process.cwd(), filePath);
    const stat = await fs.stat(filePath);
    if (stat.isDirectory() && !isIncremental) {
      tasks.push(traverse(filePath, distDir, options, compilerOptions, transform2));
    } else if (/\.(js|ts|tsx)$/.test(file) && !excludePaths.some((p) => relativePath.startsWith(p))) {
      tasks.push(
        (async () => {
          const fileContents = await fs.readFile(filePath, "utf-8");
          const compileResult = await transform2(fileContents, {
            filename: filePath,
            module: {
              type: "es6",
              strict: false,
              strictMode: true,
              lazy: false,
              noInterop: false,
              // @ts-expect-error - works but not in SWC types
              // Necessary to ensure "/index.js" imports compile correctly in Linux
              resolveFully: true
            },
            sourceMaps: env.nodeEnv === "production" ? false : "inline",
            jsc: {
              target: "esnext",
              baseUrl: options.baseUrl,
              paths: options.paths,
              parser: {
                syntax: "typescript",
                tsx: filePath.endsWith(".tsx"),
                dynamicImport: true,
                decorators: compilerOptions.experimentalDecorators ?? true
              },
              transform: {
                legacyDecorator: compilerOptions.experimentalDecorators ?? true,
                useDefineForClassFields: compilerOptions.useDefineForClassFields ?? false
              }
            }
          });
          const distPath = path.join(distDir, path.relative(srcDir, filePath.replace(/\.(js|ts|tsx)$/, ".js")));
          await fs.mkdir(path.dirname(distPath), { recursive: true });
          await fs.writeFile(distPath, compileResult.code);
        })()
      );
    }
    if (tasks.length >= parallel) {
      await Promise.all(tasks);
      tasks.length = 0;
    }
  }
  await Promise.all(tasks);
}
async function compile(options) {
  const startTime = Date.now();
  const distDir = options.distDir ? path.join(process.cwd(), options.distDir) : path.join(process.cwd(), ".robo", "build");
  if (IS_BUN && options?.plugin) {
    await preloadTypescript();
  }
  if (typeof ts === "undefined" || typeof transform === "undefined") {
    await fs.rm(distDir, { recursive: true, force: true });
    logger.debug(`Cannot find Typescript or SWC! Copying source without compiling...`);
    await copyDir(srcDir, distDir, [], options.excludePaths ?? []);
    return Date.now() - startTime;
  }
  const configFileName = path.join(process.cwd(), "tsconfig.json");
  try {
    await fs.access(configFileName);
  } catch (error2) {
    await fs.rm(distDir, { recursive: true, force: true });
    logger.debug(`Cannot find tsconfig.json! Copying source without compiling...`);
    await copyDir(srcDir, distDir, [], options.excludePaths ?? []);
    return Date.now() - startTime;
  }
  const configFileContents = await fs.readFile(configFileName, "utf8");
  const { config: tsconfig, error } = ts.parseConfigFileTextToJson(configFileName, configFileContents);
  if (error) {
    logger.error("Error parsing tsconfig.json:", error);
    process.exit(1);
  }
  const { options: tsOptions } = ts.convertCompilerOptionsFromJson(
    tsconfig.compilerOptions,
    path.dirname(configFileName)
  );
  if (tsOptions.errors) {
    logger.error("Error parsing compiler options from tsconfig.json");
    process.exit(1);
  }
  if (!options?.files?.length) {
    logger.debug(`Cleaning ${distDir}...`);
    await fs.rm(distDir, { recursive: true, force: true });
  }
  logger.debug(`Compiling ${srcDir} to ${distDir}...`);
  const baseUrl = tsOptions.baseUrl ?? process.cwd();
  const compileOptions = {
    baseUrl,
    paths: replaceSrcWithBuildInRecord(tsOptions.paths ?? {}),
    ...options ?? {}
  };
  logger.debug(`Compiler options:`, compileOptions);
  await traverse(srcDir, distDir, compileOptions, tsOptions, transform);
  await fs.rm(path.join(process.cwd(), ".swc"), { recursive: true, force: true });
  logger.debug(`Copying additional non-TypeScript files from ${srcDir} to ${distDir}...`);
  await copyDir(srcDir, distDir, [".ts", ".tsx"], options.excludePaths ?? []);
  if (options?.plugin) {
    const declarationTime = Date.now();
    logger.debug(`Generating declaration files for plugins...`);
    compileDeclarationFiles(tsOptions);
    logger.debug(`Generated declaration files in ${Date.now() - declarationTime}ms`);
  }
  logger.debug(`Compiled successfully!`);
  return Date.now() - startTime;
}
async function copyDir(src, dest, excludeExtensions, excludePaths) {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src);
  for (const entry of entries) {
    const srcPath = path.join(src, entry);
    const destPath = path.join(dest, entry);
    const entryStat = await fs.stat(srcPath);
    const entryExt = path.extname(srcPath);
    const relativePath = "/" + path.relative(process.cwd(), srcPath);
    const isIgnored = excludePaths.some((p) => relativePath.startsWith(p));
    if (isIgnored || excludeExtensions.includes(entryExt)) {
      continue;
    } else if (entryStat.isDirectory()) {
      await copyDir(srcPath, destPath, excludeExtensions, excludePaths);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}
function compileDeclarationFiles(tsOptions) {
  const options = {
    target: ts.ScriptTarget.Latest,
    rootDir: "src",
    outDir: ".robo/build",
    declaration: true,
    emitDeclarationOnly: true,
    moduleResolution: ts.ModuleResolutionKind.NodeNext,
    noEmit: false,
    skipLibCheck: true,
    ...tsOptions ?? {},
    incremental: false
  };
  const fileNames = ts.sys.readDirectory("src", [".ts", ".tsx"]);
  const program = ts.createProgram(fileNames, options);
  const emitResult = program.emit();
  const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
  allDiagnostics.forEach((diagnostic) => {
    switch (diagnostic.category) {
      case ts.DiagnosticCategory.Error:
        logger.error(formatDiagnostic(diagnostic));
        break;
      case ts.DiagnosticCategory.Warning:
        logger.warn(formatDiagnostic(diagnostic));
        break;
      case ts.DiagnosticCategory.Message:
      case ts.DiagnosticCategory.Suggestion:
        logger.info(formatDiagnostic(diagnostic));
        break;
    }
  });
  if (emitResult.emitSkipped) {
    process.exit(1);
  }
}
function formatDiagnostic(diagnostic) {
  if (diagnostic.file) {
    const { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
    return `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`;
  } else {
    return ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
  }
}

export { compile };
