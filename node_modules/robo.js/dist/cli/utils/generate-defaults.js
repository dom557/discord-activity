import { promises } from 'node:fs';
import path from 'node:path';
import { logger } from '../../core/logger.js';
import { __DIRNAME, hasProperties } from './utils.js';
import { DEBUG_MODE } from '../../core/debug.js';
import { env } from '../../core/env.js';
import { getConfig } from '../../core/config.js';

const srcDir = path.join(process.cwd(), "src");
const defaultCommandsDir = path.join(__DIRNAME, "..", "..", "default", "commands");
const defaultEventsDir = path.join(__DIRNAME, "..", "..", "default", "events");
const supportedExtensions = [".ts", ".tsx", ".js", ".jsx"];
const devCommands = [`dev${path.sep}logs`, `dev${path.sep}restart`, `dev${path.sep}status`];
async function generateDefaults(buildDir = path.join(".robo", "build")) {
  const distDir = path.join(process.cwd(), buildDir);
  const config = getConfig();
  if (config.experimental?.disableBot === true) {
    logger.debug(`Skipping default file generation for disabled bot...`);
    return { commands: {}, context: {}, events: {} };
  }
  try {
    const commands = await generateCommands(distDir, config);
    const context = {};
    const events = await generateEvents(distDir);
    return { commands, context, events };
  } catch (err) {
    logger.error("Error generating default files", err);
    process.exit(1);
  }
}
async function checkFileExistence(srcPathBase, module) {
  for (const ext of supportedExtensions) {
    const modulePath = module ? path.join("modules", module) : ".";
    const srcPath = path.join(srcDir, modulePath, srcPathBase + ext);
    try {
      await promises.access(srcPath);
      return true;
    } catch (e) {
      if (hasProperties(e, ["code"]) && e.code !== "ENOENT") {
        throw e;
      }
    }
  }
  if (!module) {
    const modules = path.join(srcDir, "modules");
    let modulesExist = false;
    try {
      modulesExist = (await promises.stat(modules))?.isDirectory();
    } catch (e) {
      if (hasProperties(e, ["code"]) && e.code !== "ENOENT") {
        throw e;
      }
    }
    if (!modulesExist) {
      return false;
    }
    const files = await promises.readdir(modules);
    for (const file of files) {
      const fullPath = path.join(modules, file);
      const fileStat = await promises.stat(fullPath);
      if (fileStat.isDirectory()) {
        const exists = await checkFileExistence(srcPathBase, file);
        if (exists) {
          return true;
        }
      }
    }
  }
  return false;
}
async function generateCommands(distDir, config) {
  const generated = {};
  await recursiveDirScan(defaultCommandsDir, async (file, fullPath) => {
    const fileExtensionPattern = /\.(ts|tsx|js|jsx)$/;
    if (!fileExtensionPattern.test(file)) {
      return;
    }
    const extension = path.extname(file);
    const commandKey = path.relative(defaultCommandsDir, fullPath).replace(extension, "");
    const shouldCreateDev = config.defaults?.dev ?? true;
    const shouldCreateHelp = config.defaults?.help ?? true;
    logger.debug(
      `Validating default command "${commandKey}":`,
      `dev: ${shouldCreateDev}, help: ${shouldCreateHelp}, debug: ${DEBUG_MODE}, guildId: ${env.discord.guildId ? "exists" : "none"}`
    );
    if (devCommands.includes(commandKey) && (!DEBUG_MODE || !env.discord.guildId || !shouldCreateDev)) {
      logger.debug(`Skipping default command:`, file);
      return;
    }
    if (commandKey === "help" && !shouldCreateHelp) {
      logger.debug(`Skipping default command:`, file);
      return;
    }
    const baseFilename = path.basename(file, extension);
    const srcPathBase = path.join("commands", commandKey.substring(0, commandKey.lastIndexOf(path.sep)), baseFilename);
    const distPath = path.join(distDir, "commands", path.relative(defaultCommandsDir, fullPath));
    const fileExists = await checkFileExistence(srcPathBase);
    if (!fileExists) {
      logger.debug(`Generating default command:`, file);
      await promises.mkdir(path.dirname(distPath), { recursive: true });
      await promises.copyFile(fullPath, distPath);
      generated[commandKey] = true;
    }
  });
  return generated;
}
async function generateEvents(distDir) {
  const generated = {};
  await recursiveDirScan(defaultEventsDir, async (file, fullPath) => {
    const fileExtensionPattern = /\.(ts|tsx|js|jsx)$/;
    if (!fileExtensionPattern.test(file)) {
      return;
    }
    const baseFilename = path.basename(file, path.extname(file));
    const distFile = "__robo_" + file;
    const distPath = path.join(distDir, "events", baseFilename, distFile);
    const extension = path.extname(file);
    const eventKey = baseFilename + path.sep + distFile.replace(extension, "");
    await promises.mkdir(path.dirname(distPath), { recursive: true });
    await promises.copyFile(fullPath, distPath);
    generated[eventKey] = true;
  });
  return generated;
}
async function recursiveDirScan(dirPath, predicate) {
  const files = await promises.readdir(dirPath);
  for (const file of files) {
    const fullPath = path.join(dirPath, file);
    const fileStat = await promises.stat(fullPath);
    if (fileStat.isDirectory()) {
      await recursiveDirScan(fullPath, predicate);
    } else {
      await predicate(file, fullPath);
    }
  }
}

export { generateDefaults };
