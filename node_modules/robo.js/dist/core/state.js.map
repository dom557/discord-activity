{"version":3,"sources":["../../src/core/state.ts"],"names":["FLASHCORE_KEYS","logger","Flashcore","state","State","prefix","options","key","getState","value","setState","builtInTypes","removeInstances","warned","item","result","processedValue","clearState","loadState","savedState","saveState","persist","newValue","oldValue","persistedState"],"mappings":"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","sourcesContent":["import { FLASHCORE_KEYS } from './constants.js'\nimport { logger } from './logger.js'\nimport { Flashcore } from './flashcore.js'\n\nexport const state: Record<string, unknown> = {}\n\nexport interface GetStateOptions {\n\tdefault?: unknown\n\tnamespace?: string\n}\n\nexport interface SetStateOptions {\n\tnamespace?: string\n\tpersist?: boolean\n}\n\nexport interface StateOptions {\n\tpersist?: boolean\n}\n\nexport class State {\n\tprivate static readonly _prefixes = new Set<string>()\n\n\tprivate readonly _prefix: string\n\tprivate readonly _options?: StateOptions\n\n\tconstructor(prefix: string, options?: StateOptions) {\n\t\tthis._prefix = prefix\n\t\tthis._options = options\n\t\tthis.fork = this.fork.bind(this)\n\t\tthis.getState = this.getState.bind(this)\n\t\tthis.setState = this.setState.bind(this)\n\t}\n\n\t/**\n\t * Creates a new state fork.\n\t * This is useful for preventing state collisions between different parts of the Robo.\n\t *\n\t * @param prefix Fork prefix (e.g. 'polls')\n\t * @param options Options for the fork (persisting all state by default)\n\t * @returns A new state fork you can deconstruct (e.g. `const { getState, setState } = State.fork('polls')`\n\t */\n\tstatic fork(prefix: string, options?: StateOptions) {\n\t\tState._prefixes.add(prefix)\n\t\treturn new State(prefix, options)\n\t}\n\n\tstatic listForks() {\n\t\treturn new Array(...State._prefixes)\n\t}\n\n\tfork(prefix: string, options?: StateOptions) {\n\t\treturn new State(`${this._prefix}__${prefix}`, options)\n\t}\n\n\t/**\n\t * Get a value from the forked state.\n\t * If the value does not exist, null is returned.\n\t *\n\t * @param key The key to get the value for.\n\t * @returns The value for the given key, or null if the key does not exist.\n\t */\n\tgetState<T = string>(key: string): T | null {\n\t\treturn getState<T>(`${this._prefix}__${key}`)\n\t}\n\n\t/**\n\t * Set a value in the forked state.\n\t * When the persist option is set to true, the state will be persisted to disk.\n\t *\n\t * @param key The key to set the value for.\n\t * @param value The value to set.\n\t * @param options Options for setting the state. (Persisting to disk)\n\t */\n\tsetState<T>(key: string, value: T, options?: SetStateOptions): void {\n\t\tsetState(`${this._prefix}__${key}`, value, {\n\t\t\t...(options ?? {}),\n\t\t\tpersist: options?.persist ?? this._options?.persist\n\t\t})\n\t}\n}\n\nconst builtInTypes = ['String', 'Number', 'Boolean', 'Array', 'Object']\n\n/**\n * Class instances are not serializable.\n * This function removes them from the state while preserving the rest of the state.\n */\nexport function removeInstances(value: unknown, warned = { value: false }): unknown {\n\tif (typeof value === 'function') {\n\t\treturn undefined\n\t}\n\n\tif (value !== null && typeof value === 'object') {\n\t\tif (!builtInTypes.includes(value.constructor.name)) {\n\t\t\tif (!warned.value) {\n\t\t\t\tlogger.warn('Removed state value as it is not serializable:', value)\n\t\t\t\twarned.value = true\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map((item) => removeInstances(item, warned)).filter((item) => item !== undefined)\n\t\t} else {\n\t\t\tconst result: Record<string, unknown> = {}\n\n\t\t\tfor (const key in value as Record<string, unknown>) {\n\t\t\t\tconst processedValue = removeInstances((value as Record<string, unknown>)[key], warned)\n\t\t\t\tif (processedValue !== undefined) {\n\t\t\t\t\tresult[key] = processedValue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\t}\n\n\treturn value\n}\n\nexport function clearState(): void {\n\tObject.keys(state).forEach((key) => {\n\t\tdelete state[key]\n\t})\n}\n\n/**\n * Get a value from the state.\n * If the value does not exist, null is returned.\n *\n * @param key The key to get the value for.\n * @returns The value for the given key, or null if the key does not exist.\n */\nexport function getState<T = string>(key: string, options?: GetStateOptions): T | null {\n\t// If a namespace is provided, prepend it to the key\n\tif (options?.namespace) {\n\t\tkey = `${options.namespace}__${key}`\n\t}\n\n\treturn (state[key] ?? options?.default) as T | null\n}\n\nexport function loadState(savedState: Record<string, unknown>) {\n\tlogger.debug(`Loading state...`, savedState)\n\tObject.keys(savedState).forEach((key) => {\n\t\tstate[key] = savedState[key]\n\t})\n}\n\nexport function saveState() {\n\tlogger.debug(`Saving state...`, state)\n\tprocess.send({ type: 'state-save', state })\n}\n\n/**\n * Set a value in the state.\n * When the persist option is set to true, the state will be persisted to disk.\n *\n * @param key The key to set the value for.\n * @param value The value to set.\n * @param options Options for setting the state. (Persisting to disk)\n */\nexport function setState<T>(key: string, value: T | ((oldValue: T) => T), options?: SetStateOptions): T {\n\tconst { persist } = options ?? {}\n\n\t// If a namespace is provided, prepend it to the key\n\tif (options?.namespace) {\n\t\tkey = `${options.namespace}__${key}`\n\t}\n\n\t// If value is a function, use it to compute the new value based on the old value\n\tlet newValue = value\n\tif (typeof value === 'function') {\n\t\tconst oldValue = state[key] as T\n\t\tnewValue = (value as (oldValue: T) => T)(oldValue as T)\n\t}\n\n\t// Apply the new value to the state\n\tstate[key] = newValue\n\n\t// Persist state to disk if requested\n\tif (persist) {\n\t\tconst persistState = async () => {\n\t\t\tconst persistedState = (await Flashcore.get<Record<string, unknown>>(FLASHCORE_KEYS.state)) ?? {}\n\t\t\tpersistedState[key] = newValue\n\t\t\tFlashcore.set(FLASHCORE_KEYS.state, persistedState)\n\t\t}\n\t\tpersistState()\n\t}\n\n\treturn newValue as T\n}\n"]}