{"version":3,"sources":["../../src/core/flashcore-fs.ts"],"names":["fs","path","pipeline","zlib","createReadStream","createWriteStream","logger","hasProperties","createHash","FlashcoreFileAdapter","key","fileName","e","gunzip","decompressed","value","gzip"],"mappings":"AAAA,OAAOA,MAAQ,mBACf,OAAOC,MAAU,YACjB,OAAS,YAAAC,MAAgB,uBACzB,OAAOC,MAAU,YACjB,OAAS,oBAAAC,EAAkB,qBAAAC,MAAyB,UACpD,OAAS,UAAAC,MAAc,cACvB,OAAS,iBAAAC,MAAqB,wBAC9B,OAAS,cAAAC,MAAkB,cAGpB,MAAMC,CAAgF,CAC5F,OAAe,SAAWR,EAAK,KAAK,QAAQ,IAAI,EAAG,QAAS,MAAM,EAElE,MAAM,OAA0B,CAC/B,GAAI,CACH,aAAMD,EAAG,GAAGS,EAAqB,SAAU,CAAE,UAAW,GAAM,MAAO,EAAK,CAAC,EAC3E,MAAMT,EAAG,MAAMS,EAAqB,SAAU,CAAE,UAAW,EAAK,CAAC,EAC1D,EACR,MAAE,CACD,MAAO,EACR,CACD,CAEA,MAAM,OAAOC,EAA0B,CACtC,GAAI,CACH,MAAMC,EAAWV,EAAK,KAAKQ,EAAqB,SAAU,KAAK,YAAYC,CAAG,CAAC,EAC/E,aAAMV,EAAG,OAAOW,CAAQ,EACjB,EACR,OAASC,EAAP,CAED,OAAIL,EAAiCK,EAAG,CAAC,MAAM,CAAC,GAAKA,EAAE,OAAS,UAC/DN,EAAO,KAAK,yBAAyBI,kCAAqCE,CAAC,EAGrE,EACR,CACD,CAEA,MAAM,IAAIF,EAAgC,CACzC,GAAI,CACH,MAAMC,EAAWV,EAAK,KAAKQ,EAAqB,SAAU,KAAK,YAAYC,CAAG,CAAC,EACzEG,EAASV,EAAK,aAAa,EACjC,MAAMD,EAASE,EAAiBO,CAAQ,EAAGE,CAAM,EACjD,MAAMC,EAAeD,EAAO,KAAK,EACjC,OAAOC,EAAgB,KAAK,MAAMA,EAAa,SAAS,CAAC,EAAU,MACpE,MAAE,CACD,MACD,CACD,CAEA,MAAM,IAAIJ,EAA0B,CACnC,MAAO,CAAC,CAAE,MAAM,KAAK,IAAIA,CAAG,CAC7B,CAEA,MAAM,MAAO,CACZ,GAAI,CACH,MAAMV,EAAG,MAAMS,EAAqB,SAAU,CAAE,UAAW,EAAK,CAAC,CAClE,OAAS,EAAP,CACDH,EAAO,MAAM,8DAA+D,CAAC,CAC9E,CACD,CAEA,MAAM,IAAII,EAAQK,EAA4B,CAC7C,GAAI,CACH,MAAMJ,EAAWV,EAAK,KAAKQ,EAAqB,SAAU,KAAK,YAAYC,CAAG,CAAC,EACzEM,EAAOb,EAAK,WAAW,EAC7B,OAAAa,EAAK,MAAM,KAAK,UAAUD,CAAK,CAAC,EAChCC,EAAK,IAAI,EACT,MAAMd,EAASc,EAAMX,EAAkBM,CAAQ,CAAC,EACzC,EACR,MAAE,CACD,MAAO,EACR,CACD,CAEQ,YAAYD,EAAgB,CACnC,OAAOF,EAAW,QAAQ,EAAE,OAAOE,EAAI,SAAS,CAAC,EAAE,OAAO,KAAK,CAChE,CACD","sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport { pipeline } from 'node:stream/promises'\nimport zlib from 'node:zlib'\nimport { createReadStream, createWriteStream } from 'node:fs'\nimport { logger } from './logger.js'\nimport { hasProperties } from '../cli/utils/utils.js'\nimport { createHash } from 'node:crypto'\nimport type { FlashcoreAdapter } from '../types/index.js'\n\nexport class FlashcoreFileAdapter<K = string, V = unknown> implements FlashcoreAdapter<K, V> {\n\tprivate static DATA_DIR = path.join(process.cwd(), '.robo', 'data')\n\n\tasync clear(): Promise<boolean> {\n\t\ttry {\n\t\t\tawait fs.rm(FlashcoreFileAdapter.DATA_DIR, { recursive: true, force: true })\n\t\t\tawait fs.mkdir(FlashcoreFileAdapter.DATA_DIR, { recursive: true })\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tasync delete(key: K): Promise<boolean> {\n\t\ttry {\n\t\t\tconst fileName = path.join(FlashcoreFileAdapter.DATA_DIR, this._getSafeKey(key))\n\t\t\tawait fs.unlink(fileName)\n\t\t\treturn true\n\t\t} catch (e) {\n\t\t\t// Warn about failures except ENOENT because that just means the key doesn't exist (normal)\n\t\t\tif (hasProperties<{ code: unknown }>(e, ['code']) && e.code !== 'ENOENT') {\n\t\t\t\tlogger.warn(`Failed to delete key \"${key}\" from Flashcore file adapter.`, e)\n\t\t\t}\n\n\t\t\treturn false\n\t\t}\n\t}\n\n\tasync get(key: K): Promise<V | undefined> {\n\t\ttry {\n\t\t\tconst fileName = path.join(FlashcoreFileAdapter.DATA_DIR, this._getSafeKey(key))\n\t\t\tconst gunzip = zlib.createGunzip()\n\t\t\tawait pipeline(createReadStream(fileName), gunzip)\n\t\t\tconst decompressed = gunzip.read()\n\t\t\treturn decompressed ? (JSON.parse(decompressed.toString()) as V) : undefined\n\t\t} catch {\n\t\t\treturn undefined\n\t\t}\n\t}\n\n\tasync has(key: K): Promise<boolean> {\n\t\treturn !!(await this.get(key))\n\t}\n\n\tasync init() {\n\t\ttry {\n\t\t\tawait fs.mkdir(FlashcoreFileAdapter.DATA_DIR, { recursive: true })\n\t\t} catch (e) {\n\t\t\tlogger.error('Failed to create data directory for Flashcore file adapter.', e)\n\t\t}\n\t}\n\n\tasync set(key: K, value: V): Promise<boolean> {\n\t\ttry {\n\t\t\tconst fileName = path.join(FlashcoreFileAdapter.DATA_DIR, this._getSafeKey(key))\n\t\t\tconst gzip = zlib.createGzip()\n\t\t\tgzip.write(JSON.stringify(value))\n\t\t\tgzip.end()\n\t\t\tawait pipeline(gzip, createWriteStream(fileName))\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tprivate _getSafeKey(key: K): string {\n\t\treturn createHash('sha256').update(key.toString()).digest('hex')\n\t}\n}\n"]}