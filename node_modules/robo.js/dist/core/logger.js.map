{"version":3,"sources":["../../src/core/logger.ts"],"names":["inspect","color","env","DEBUG_MODE","ANSI_REGEX","pendingDrains","consoleDrain","logger","level","data","writeLog","stream","resolve","reject","parts","item","error","DEFAULT_MAX_ENTRIES","LogEntry","Logger","options","customLevels","drain","enabled","parent","prefix","LogLevelValues","key","value","levelLabel","colorizedLogLevels","colorMap","promise","count","startIndex","recentLogs","_logger"],"mappings":"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","sourcesContent":["import { inspect } from 'node:util'\nimport { color } from './color.js'\nimport { env } from './env.js'\n\nexport type LogDrain = (logger: Logger, level: string, ...data: unknown[]) => Promise<void>\n\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'wait' | 'other' | 'event' | 'ready' | 'warn' | 'error'\n\ninterface CustomLevel {\n\tlabel: string\n\tpriority: number\n}\n\nexport interface LoggerOptions {\n\tcustomLevels?: Record<string, CustomLevel>\n\tdrain?: LogDrain\n\tenabled?: boolean\n\tlevel?: LogLevel | string\n\tmaxEntries?: number\n\tparent?: Logger\n\tprefix?: string\n}\n\nexport const DEBUG_MODE = process.env.NODE_ENV !== 'production'\n\n// eslint-disable-next-line no-control-regex\nexport const ANSI_REGEX = /\\x1b\\[.*?m/g\n\nconst pendingDrains = new Set<Promise<void>>()\n\ntype LogStream = typeof process.stderr | typeof process.stdout\n\nfunction consoleDrain(logger: Logger, level: string, ...data: unknown[]): Promise<void> {\n\tswitch (level) {\n\t\tcase 'trace':\n\t\tcase 'debug':\n\t\tcase 'info':\n\t\tcase 'wait':\n\t\tcase 'event':\n\t\t\treturn writeLog(process.stdout, ...data)\n\t\tcase 'warn':\n\t\tcase 'error':\n\t\t\treturn writeLog(process.stderr, ...data)\n\t\tdefault:\n\t\t\treturn writeLog(process.stdout, ...data)\n\t}\n}\n\nfunction writeLog(stream: LogStream, ...data: unknown[]) {\n\treturn new Promise<void>((resolve, reject) => {\n\t\tconst parts = data?.map((item) => {\n\t\t\tif (typeof item === 'object' || item instanceof Error || Array.isArray(item)) {\n\t\t\t\treturn inspect(item, { colors: true, depth: null })\n\t\t\t}\n\t\t\treturn item\n\t\t})\n\n\t\tstream.write(parts?.join(' ') + '\\n', 'utf8', (error) => {\n\t\t\tif (error) reject(error)\n\t\t\telse resolve()\n\t\t})\n\t})\n}\n\nconst DEFAULT_MAX_ENTRIES = 100\n\nclass LogEntry {\n\tlevel: string\n\ttimestamp: Date\n\tdata: unknown[]\n\n\tconstructor(level: string, data: unknown[]) {\n\t\tthis.level = level\n\t\tthis.data = data\n\t\tthis.timestamp = new Date()\n\t}\n\n\tmessage(): string {\n\t\tconst messageParts = this.data.map((item) => {\n\t\t\tif (item instanceof Error) {\n\t\t\t\treturn item.message\n\t\t\t} else if (typeof item === 'object') {\n\t\t\t\ttry {\n\t\t\t\t\treturn JSON.stringify(item)\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// In case of circular structures or other stringify errors, return a fallback string\n\t\t\t\t\treturn '[unserializable object]'\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn item\n\t\t})\n\n\t\treturn messageParts.join(' ').replace(ANSI_REGEX, '')\n\t}\n}\n\nexport class Logger {\n\tprotected _customLevels: Record<string, CustomLevel>\n\tprotected _enabled: boolean\n\tprotected _level: LogLevel | string\n\tprotected _levelValues: Record<string, number>\n\tprotected _parent: Logger | undefined\n\tprotected _prefix: string | undefined\n\tprivate _currentIndex: number\n\tprivate _drain: LogDrain\n\tprivate _logBuffer: LogEntry[]\n\n\tconstructor(options?: LoggerOptions) {\n\t\tthis.setup(options)\n\t}\n\n\tpublic setup(options?: LoggerOptions) {\n\t\tconst { customLevels, drain = consoleDrain, enabled = true, level, parent, prefix } = options ?? {}\n\n\t\tthis._customLevels = customLevels\n\t\tthis._drain = drain\n\t\tthis._enabled = enabled\n\t\tthis._parent = parent\n\t\tthis._prefix = prefix\n\n\t\tif (env.roboplay.env) {\n\t\t\t// This allows developers to have better control over the logs when hosted\n\t\t\tthis._level = 'trace'\n\t\t} else {\n\t\t\tthis._level = level ?? 'info'\n\t\t}\n\n\t\t// Combine the default log levels with the custom ones\n\t\tthis._levelValues = {\n\t\t\t...LogLevelValues,\n\t\t\t...Object.fromEntries(Object.entries(this._customLevels ?? {}).map(([key, value]) => [key, value.priority]))\n\t\t}\n\n\t\t// Initialize the log buffer\n\t\tthis._currentIndex = 0\n\t\tthis._logBuffer = new Array(options?.maxEntries ?? DEFAULT_MAX_ENTRIES)\n\t}\n\n\tprotected _log(prefix: string | null, level: string, ...data: unknown[]): void {\n\t\t// Delegate to parent if forked\n\t\tif (this._parent) {\n\t\t\treturn this._parent._log(this._prefix, level, ...data)\n\t\t}\n\n\t\t// Only log if the level is enabled\n\t\tif (!this._enabled) {\n\t\t\treturn\n\t\t}\n\n\t\t// If using the default drain, perform the level check\n\t\tif (this._drain === consoleDrain && this._levelValues[this._level] > this._levelValues[level]) {\n\t\t\treturn\n\t\t}\n\n\t\t// Format the message all pretty and stuff\n\t\tif (level !== 'other') {\n\t\t\tconst label = this._customLevels ? this._customLevels[level]?.label : colorizedLogLevels[level]\n\t\t\tlet levelLabel = (label ?? level.padEnd(5)) + ' -'\n\n\t\t\t// Add the prefix if specified\n\t\t\tif (prefix) {\n\t\t\t\tlevelLabel = color.bold(colorMap[level](prefix + ':')) + levelLabel\n\t\t\t}\n\n\t\t\tdata.unshift(levelLabel)\n\t\t}\n\n\t\t// Persist the log entry in debug mode\n\t\tif (DEBUG_MODE) {\n\t\t\tthis._logBuffer[this._currentIndex] = new LogEntry(level, data)\n\t\t\tthis._currentIndex = (this._currentIndex + 1) % this._logBuffer.length\n\t\t}\n\n\t\t// Drain the log entry\n\t\tconst promise = this._drain(this, level, ...data)\n\t\tpendingDrains.add(promise)\n\t\tpromise.finally(() => {\n\t\t\tpendingDrains.delete(promise)\n\t\t})\n\t}\n\n\t/**\n\t * Waits for all pending log writes to complete.\n\t */\n\tpublic async flush(): Promise<void> {\n\t\t// Delegate to parent if forked\n\t\tif (this._parent) {\n\t\t\treturn this._parent.flush()\n\t\t}\n\n\t\tawait Promise.allSettled([...pendingDrains])\n\t}\n\n\t/**\n\t * Creates a new logger instance with the specified prefix.\n\t * This is useful for creating a logger for a specific plugin, big features, or modules.\n\t *\n\t * All writes and cached logs will be delegated to the parent logger, so debugging will still work.\n\t *\n\t * @param prefix The prefix to add to the logger (e.g. 'my-plugin')\n\t * @returns A new logger instance with the specified prefix\n\t */\n\tpublic fork(prefix: string): Logger {\n\t\treturn new Logger({\n\t\t\tcustomLevels: this._customLevels,\n\t\t\tenabled: this._enabled,\n\t\t\tlevel: this._level,\n\t\t\tparent: this,\n\t\t\tprefix: this._prefix ? this._prefix + prefix : prefix\n\t\t})\n\t}\n\n\tpublic getLevel(): LogLevel | string {\n\t\t// Delegate to parent if forked\n\t\tif (this._parent) {\n\t\t\treturn this._parent.getLevel()\n\t\t}\n\n\t\treturn this._level\n\t}\n\n\tpublic getLevelValues(): Record<string, number> {\n\t\t// Delegate to parent if forked\n\t\tif (this._parent) {\n\t\t\treturn this._parent.getLevelValues()\n\t\t}\n\n\t\treturn this._levelValues\n\t}\n\n\tpublic getRecentLogs(count = 50): LogEntry[] {\n\t\t// Delegate to parent if forked\n\t\tif (this._parent) {\n\t\t\treturn this._parent.getRecentLogs(count)\n\t\t}\n\n\t\t// Return an empty array if the log buffer is empty\n\t\tif (count <= 0) {\n\t\t\treturn []\n\t\t}\n\n\t\t// Ensure the count doesn't exceed the number of logs in the buffer\n\t\tcount = Math.min(count, this._logBuffer.length)\n\t\tconst startIndex = (this._currentIndex - count + this._logBuffer.length) % this._logBuffer.length\n\t\tlet recentLogs: LogEntry[]\n\n\t\tif (startIndex < this._currentIndex) {\n\t\t\trecentLogs = this._logBuffer.slice(startIndex, this._currentIndex)\n\t\t} else {\n\t\t\trecentLogs = this._logBuffer.slice(startIndex).concat(this._logBuffer.slice(0, this._currentIndex))\n\t\t}\n\n\t\treturn recentLogs.reverse()\n\t}\n\n\tpublic setDrain(drain: LogDrain) {\n\t\tthis._drain = drain\n\t}\n\n\tpublic trace(...data: unknown[]) {\n\t\tthis._log(null, 'trace', ...data)\n\t}\n\n\tpublic debug(...data: unknown[]) {\n\t\tthis._log(null, 'debug', ...data)\n\t}\n\n\tpublic info(...data: unknown[]) {\n\t\tthis._log(null, 'info', ...data)\n\t}\n\n\tpublic wait(...data: unknown[]) {\n\t\tthis._log(null, 'wait', ...data)\n\t}\n\n\tpublic log(...data: unknown[]) {\n\t\tthis._log(null, 'other', ...data)\n\t}\n\n\tpublic event(...data: unknown[]) {\n\t\tthis._log(null, 'event', ...data)\n\t}\n\n\tpublic ready(...data: unknown[]) {\n\t\tthis._log(null, 'ready', ...data)\n\t}\n\n\tpublic warn(...data: unknown[]) {\n\t\tthis._log(null, 'warn', ...data)\n\t}\n\n\tpublic error(...data: unknown[]) {\n\t\tthis._log(null, 'error', ...data)\n\t}\n\n\tpublic custom(level: string, ...data: unknown[]): void {\n\t\tif (this._customLevels?.[level]) {\n\t\t\tthis._log(null, level, ...data)\n\t\t}\n\t}\n}\n\nconst LogLevelValues: Record<string, number> = {\n\ttrace: 0,\n\tdebug: 1,\n\tinfo: 2,\n\twait: 3,\n\tother: 4,\n\tevent: 5,\n\tready: 6,\n\twarn: 7,\n\terror: 8\n}\n\nconst colorMap: Record<string, (str: string) => string> = {\n\ttrace: color.gray,\n\tdebug: color.cyan,\n\tinfo: color.blue,\n\twait: color.cyan,\n\tevent: color.magenta,\n\tready: color.green,\n\twarn: color.yellow,\n\terror: color.red\n}\n\nconst colorizedLogLevels: Record<string, string> = {\n\ttrace: color.gray('trace'.padEnd(5)),\n\tdebug: color.cyan('debug'.padEnd(5)),\n\tinfo: color.blue('info'.padEnd(5)),\n\twait: color.cyan('wait'.padEnd(5)),\n\tevent: color.magenta('event'.padEnd(5)),\n\tready: color.green('ready'.padEnd(5)),\n\twarn: color.yellow('warn'.padEnd(5)),\n\terror: color.red('error'.padEnd(5))\n}\n\nlet _logger: Logger | null = null\n\nexport function logger(options?: LoggerOptions): Logger {\n\tif (!_logger && options) {\n\t\t_logger = new Logger(options)\n\t} else if (!_logger) {\n\t\t_logger = new Logger()\n\t} else if (options) {\n\t\t_logger.setup(options)\n\t}\n\n\treturn _logger\n}\n\nlogger.flush = async function (): Promise<void> {\n\tawait logger().flush()\n}\n\nlogger.fork = function (prefix: string): Logger {\n\treturn logger().fork(prefix)\n}\n\nlogger.getRecentLogs = function (count = 25): LogEntry[] {\n\treturn logger().getRecentLogs(count)\n}\n\nlogger.trace = function (...data: unknown[]): void {\n\treturn logger().trace(...data)\n}\n\nlogger.debug = function (...data: unknown[]): void {\n\treturn logger().debug(...data)\n}\n\nlogger.info = function (...data: unknown[]): void {\n\treturn logger().info(...data)\n}\n\nlogger.wait = function (...data: unknown[]): void {\n\treturn logger().wait(...data)\n}\n\nlogger.log = function (...data: unknown[]): void {\n\treturn logger().log(...data)\n}\n\nlogger.event = function (...data: unknown[]): void {\n\treturn logger().event(...data)\n}\n\nlogger.ready = function (...data: unknown[]): void {\n\treturn logger().ready(...data)\n}\n\nlogger.warn = function (...data: unknown[]): void {\n\treturn logger().warn(...data)\n}\n\nlogger.error = function (...data: unknown[]): void {\n\treturn logger().error(...data)\n}\n\nlogger.custom = function (level: string, ...data: unknown[]): void {\n\treturn logger().custom(level, ...data)\n}\n"]}