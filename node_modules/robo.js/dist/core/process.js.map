{"version":3,"sources":["../../src/core/process.ts"],"names":["registerProcessEvents","logger","Robo","reason","loadConfig","env","client","sendDebugError"],"mappings":"AASO,SAASA,GAAwB,CACvC,QAAQ,GAAG,SAAU,SAAY,CAChC,KAAM,CAAE,OAAAC,CAAO,EAAI,KAAM,QAAO,aAAa,EACvC,CAAE,KAAAC,CAAK,EAAI,KAAM,QAAO,WAAW,EAEzCD,EAAO,MAAM,yBAAyB,EACtCC,EAAK,KAAK,CACX,CAAC,EAED,QAAQ,GAAG,UAAW,SAAY,CACjC,KAAM,CAAE,OAAAD,CAAO,EAAI,KAAM,QAAO,aAAa,EACvC,CAAE,KAAAC,CAAK,EAAI,KAAM,QAAO,WAAW,EAEzCD,EAAO,MAAM,0BAA0B,EACvCC,EAAK,KAAK,CACX,CAAC,EAED,QAAQ,GAAG,qBAAsB,MAAOC,GAAW,CAClD,KAAM,CAAE,WAAAC,CAAW,EAAI,KAAM,QAAO,aAAa,EAC3C,CAAE,IAAAC,CAAI,EAAI,KAAM,QAAO,UAAU,EACjC,CAAE,OAAAJ,CAAO,EAAI,KAAM,QAAO,aAAa,EACvC,CAAE,OAAAK,EAAQ,KAAAJ,CAAK,EAAI,KAAM,QAAO,WAAW,EAiBjD,GAhBAD,EAAO,MAAME,CAAM,GAGJ,MAAMC,EAAW,GAErB,cAAc,aAMpBE,GAAQ,QAAQ,GACpB,QAAQ,KAAK,CAAC,EAIXD,EAAI,UAAY,cACnB,OAKD,KAAM,CAAE,eAAAE,CAAe,EAAI,KAAM,QAAO,YAAY,EAC/B,MAAMA,EAAeJ,CAAM,GAE/CD,EAAK,KAAK,CAAC,CAEb,CAAC,EAGG,OAAO,QAAQ,MAAS,YAC3B,QAAQ,OAAO,CAAE,KAAM,OAAQ,CAAC,EAIjC,WAAW,IAAM,CACZ,OAAO,QAAQ,MAAS,YAC3B,QAAQ,OAAO,CAAE,KAAM,QAAS,QAAS,EAAK,CAAC,CAEjD,EAAG,GAAK,CACT","sourcesContent":["/**\n * Registering process events ensure the \"ready\" signal is sent to the parent process.\n * Not doing this may cause the process to hang if any setup causes an error.\n * It's just as important to be able to receive messages from the parent process quickly.\n *\n * Note:\n * - Development mode waits for these events to be registered prior to continuing listening for changes.\n * - Imports are done inline to avoid potential crashes due to errors in them.\n */\nexport function registerProcessEvents() {\n\tprocess.on('SIGINT', async () => {\n\t\tconst { logger } = await import('./logger.js')\n\t\tconst { Robo } = await import('./robo.js')\n\n\t\tlogger.debug('Received SIGINT signal.')\n\t\tRobo.stop()\n\t})\n\n\tprocess.on('SIGTERM', async () => {\n\t\tconst { logger } = await import('./logger.js')\n\t\tconst { Robo } = await import('./robo.js')\n\n\t\tlogger.debug('Received SIGTERM signal.')\n\t\tRobo.stop()\n\t})\n\n\tprocess.on('unhandledRejection', async (reason) => {\n\t\tconst { loadConfig } = await import('./config.js')\n\t\tconst { env } = await import('./env.js')\n\t\tconst { logger } = await import('./logger.js')\n\t\tconst { client, Robo } = await import('./robo.js')\n\t\tlogger.error(reason)\n\n\t\t// Load config file to see if we need handling\n\t\tconst config = await loadConfig()\n\n\t\tif (config.experimental?.disableBot) {\n\t\t\treturn\n\t\t}\n\n\t\t// Exit right away if the client isn't ready yet\n\t\t// We don't want to send a message to Discord nor notify handlers if we can't\n\t\tif (!client?.isReady()) {\n\t\t\tprocess.exit(1)\n\t\t}\n\n\t\t// Log error and ignore it in production\n\t\tif (env.nodeEnv === 'production') {\n\t\t\treturn\n\t\t}\n\n\t\t// Development mode works a bit differently because we don't want developers to ignore errors\n\t\t// Errors will stop the process unless there's a special channel to send them to\n\t\tconst { sendDebugError } = await import('./debug.js')\n\t\tconst handledError = await sendDebugError(reason)\n\t\tif (!handledError) {\n\t\t\tRobo.stop(1)\n\t\t}\n\t})\n\n\t// Tell the parent process we're ready to receive messages\n\tif (typeof process.send === 'function') {\n\t\tprocess.send?.({ type: 'ready' })\n\t}\n\n\t// Backup message with delay to prevent race conditions\n\tsetTimeout(() => {\n\t\tif (typeof process.send === 'function') {\n\t\t\tprocess.send?.({ type: 'ready', delayed: true })\n\t\t}\n\t}, 1_000)\n}\n"]}