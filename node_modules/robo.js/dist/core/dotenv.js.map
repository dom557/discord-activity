{"version":3,"sources":["../../src/core/dotenv.ts"],"names":["existsSync","readFileSync","readFile","path","IS_BUN","parseEnvFile","envFileContent","lines","commentRegex","quotesRegex","escapedCharsRegex","currentLine","newEnvVars","i","delimiterIndex","key","value","loadEnv","options","filePath","varSubstitutionRegex","envClone","visited","_","varName","err"],"mappings":"AAAA,OAAS,cAAAA,EAAY,gBAAAC,MAAoB,UACzC,OAAS,YAAAC,MAAgB,mBACzB,OAAOC,MAAU,YACjB,OAAS,UAAAC,MAAc,gCAEvB,SAASC,EAAaC,EAAmD,CACxE,MAAMC,EAAQD,EAAe,MAAM;AAAA,CAAI,EACjCE,EAAe,QACfC,EAAc,QACdC,EAAoB,SAE1B,IAAIC,EAAc,GAClB,MAAMC,EAAwC,CAAC,EAE/C,QAASC,EAAI,EAAGA,EAAIN,EAAM,OAAQM,IAAK,CAItC,GAHAF,GAAeJ,EAAMM,CAAC,EAGlBL,EAAa,KAAKG,CAAW,EAAG,CACnCA,EAAc,GACd,SAID,GAAIA,EAAY,SAAS,IAAI,EAAG,CAC/BA,EAAcA,EAAY,MAAM,EAAG,EAAE,EACrC,SAID,MAAMG,EAAiBH,EAAY,QAAQ,GAAG,EAC9C,GAAIG,IAAmB,GAAI,CAC1BH,EAAc,GACd,SAGD,MAAMI,EAAMJ,EAAY,OAAO,EAAGG,CAAc,EAAE,KAAK,EACvD,IAAIE,EAAQL,EAAY,OAAOG,EAAiB,CAAC,EAAE,KAAK,EAGpDL,EAAY,KAAKO,CAAK,IACzBA,EAAQA,EAAM,MAAM,EAAG,EAAE,EAAE,QAAQN,EAAmB,IAAI,GAG3DE,EAAWG,CAAG,EAAIC,EAClBL,EAAc,GAGf,OAAOC,CACR,CAEA,eAAsBK,EAAQC,EAAiD,CAAC,EAAkB,CAEjG,GAAId,EACH,OAGD,KAAM,CAAE,SAAAe,EAAWhB,EAAK,KAAK,QAAQ,IAAI,EAAG,MAAM,CAAE,EAAIe,EACxD,GAAI,CAAClB,EAAWmB,CAAQ,EACvB,OAGD,MAAMb,EAAiBY,EAAQ,KAAOjB,EAAakB,EAAU,OAAO,EAAI,MAAMjB,EAASiB,EAAU,OAAO,EAClGP,EAAaP,EAAaC,CAAc,EACxCc,EAAuB,aAGvBC,EAAW,CAAE,GAAG,QAAQ,GAAI,EAElC,GAAI,CACH,UAAWN,KAAOH,EAAY,CAC7B,GAAIG,KAAOM,EAAU,SAErB,MAAMC,EAAU,IAAI,IACpB,IAAIN,EAAQJ,EAAWG,CAAG,EAE1B,KAAOK,EAAqB,KAAKJ,CAAK,GACrCA,EAAQA,EAAM,QAAQI,EAAsB,CAACG,EAAGC,IAAY,CAC3D,GAAIF,EAAQ,IAAIE,CAAO,EACtB,MAAM,IAAI,MAAM,wDAAwDT,IAAM,EAE/E,OAAAO,EAAQ,IAAIE,CAAO,EACZH,EAASG,CAAO,GAAKZ,EAAWY,CAAO,GAAK,EACpD,CAAC,EAGFH,EAASN,CAAG,EAAIC,EAGjB,OAAO,OAAO,QAAQ,IAAKK,CAAQ,CACpC,OAASI,EAAP,CACD,QAAQ,MAAM,6CAA8CA,CAAG,CAChE,CACD","sourcesContent":["import { existsSync, readFileSync } from 'node:fs'\nimport { readFile } from 'node:fs/promises'\nimport path from 'node:path'\nimport { IS_BUN } from '../cli/utils/runtime-utils.js'\n\nfunction parseEnvFile(envFileContent: string): { [key: string]: string } {\n\tconst lines = envFileContent.split('\\n')\n\tconst commentRegex = /^\\s*#/\n\tconst quotesRegex = /^['\"]/\n\tconst escapedCharsRegex = /\\\\(.)/g\n\n\tlet currentLine = ''\n\tconst newEnvVars: { [key: string]: string } = {}\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tcurrentLine += lines[i]\n\n\t\t// Ignore comments\n\t\tif (commentRegex.test(currentLine)) {\n\t\t\tcurrentLine = ''\n\t\t\tcontinue\n\t\t}\n\n\t\t// Multiline support\n\t\tif (currentLine.endsWith('\\\\')) {\n\t\t\tcurrentLine = currentLine.slice(0, -1)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Find first index of '=', and split key/value there\n\t\tconst delimiterIndex = currentLine.indexOf('=')\n\t\tif (delimiterIndex === -1) {\n\t\t\tcurrentLine = ''\n\t\t\tcontinue // Ignore lines that aren't key-value pairs\n\t\t}\n\n\t\tconst key = currentLine.substr(0, delimiterIndex).trim()\n\t\tlet value = currentLine.substr(delimiterIndex + 1).trim()\n\n\t\t// Remove surrounding quotes and unescape\n\t\tif (quotesRegex.test(value)) {\n\t\t\tvalue = value.slice(1, -1).replace(escapedCharsRegex, '$1')\n\t\t}\n\n\t\tnewEnvVars[key] = value\n\t\tcurrentLine = ''\n\t}\n\n\treturn newEnvVars\n}\n\nexport async function loadEnv(options: { filePath?: string; sync?: boolean } = {}): Promise<void> {\n\t// No need to load .env file if using Bun (it's already loaded)\n\tif (IS_BUN) {\n\t\treturn\n\t}\n\n\tconst { filePath = path.join(process.cwd(), '.env') } = options\n\tif (!existsSync(filePath)) {\n\t\treturn\n\t}\n\n\tconst envFileContent = options.sync ? readFileSync(filePath, 'utf-8') : await readFile(filePath, 'utf-8')\n\tconst newEnvVars = parseEnvFile(envFileContent)\n\tconst varSubstitutionRegex = /\\${(.+?)}/g\n\n\t// Create a clone of process.env to maintain a consistent state in case of an error\n\tconst envClone = { ...process.env }\n\n\ttry {\n\t\tfor (const key in newEnvVars) {\n\t\t\tif (key in envClone) continue // Don't overwrite existing values\n\n\t\t\tconst visited = new Set<string>()\n\t\t\tlet value = newEnvVars[key]\n\n\t\t\twhile (varSubstitutionRegex.test(value)) {\n\t\t\t\tvalue = value.replace(varSubstitutionRegex, (_, varName) => {\n\t\t\t\t\tif (visited.has(varName)) {\n\t\t\t\t\t\tthrow new Error(`Circular reference detected in environment variable \"${key}\"`)\n\t\t\t\t\t}\n\t\t\t\t\tvisited.add(varName)\n\t\t\t\t\treturn envClone[varName] || newEnvVars[varName] || ''\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tenvClone[key] = value\n\t\t}\n\n\t\tObject.assign(process.env, envClone)\n\t} catch (err) {\n\t\tconsole.error(`Error while loading environment variables:`, err)\n\t}\n}\n"]}