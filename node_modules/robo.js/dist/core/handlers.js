import { portal } from './robo.js';
import { timeout, getSage } from '../cli/utils/utils.js';
import { getConfig } from './config.js';
import { discordLogger, BUFFER, TIMEOUT, DEFAULT_CONFIG } from './constants.js';
import { printErrorResponse } from './debug.js';
import { color } from './color.js';
import g from 'node:path';

const j=["boolean","integer","number","string"];async function B(e,i){const r=portal.commands.get(i);if(!r){discordLogger.error(`No command matching ${i} was found.`);return}if(!portal.module(r.module).isEnabled){discordLogger.debug(`Tried to execute disabled command from module: ${color.bold(r.module)}`);return}try{for(const s of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(s.plugin?.path??".",s.path))}`);const l=await s.handler.default({payload:[e],record:r});if(l&&l.abort){discordLogger.debug(`Middleware aborted autocomplete: ${color.bold(e.commandName)}`);return}}}catch(s){discordLogger.error("Aborting due to middleware error:",s);return}const d=getConfig();try{discordLogger.debug(`Executing autocomplete handler: ${color.bold(g.join(r.plugin?.path??".",r.path))}`);const s=[r.handler.autocomplete(e)],l=d?.timeouts?.autocomplete;l&&s.push(timeout(()=>[],l));const o=await Promise.race(s);if(!o)throw new Error("Autocomplete timed out");await e.respond(o);}catch(s){discordLogger.error("Autocomplete error:",s);}}async function L(e,i){const r=portal.commands.get(i);if(!r){discordLogger.error(`No command matching "${i}" was found.`);return}if(!portal.module(r.module).isEnabled){discordLogger.debug(`Tried to execute disabled command from module: ${color.bold(r.module)}`);return}try{for(const o of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(o.plugin?.path??".",o.path))}`);const a=await o.handler.default({payload:[e],record:r});if(a&&a.abort){discordLogger.debug(`Middleware aborted command: ${color.bold(i)}`);return}}}catch(o){discordLogger.error("Aborting due to middleware error:",o);return}const d=r.handler.config,s=getConfig(),l=getSage(d,s);discordLogger.debug("Sage options:",l);try{if(discordLogger.debug(`Executing command handler: ${color.bold(g.join(r.plugin?.path??".",r.path))}`),!r.handler.default)throw `Missing default export function for command: ${color.bold("/"+i)}`;const o=I(e,d?.options),a=r.handler.default(e,o),u=[];let n;if(l.defer&&a instanceof Promise){const y=timeout(()=>BUFFER,l.deferBuffer),C=await Promise.race([a,y]);if(C===BUFFER&&!e.replied){if(discordLogger.debug("Sage is deferring async command..."),u.push(a),!e.deferred)try{await e.deferReply({ephemeral:l.ephemeral});}catch(b){const $=b instanceof Error?b.message:b;if(!$.includes("Unknown interaction")&&!$.includes("Interaction has already been acknowledged"))throw b;discordLogger.debug("Interaction was already handled, skipping Sage deferral");}}else n=C;}if(u.length>0){if(s?.timeouts?.commandDeferral&&u.push(timeout(()=>TIMEOUT,s.timeouts.commandDeferral)),n=await Promise.race(u),n===TIMEOUT)throw new Error("Command timed out")}else a instanceof Promise||(n=a);if(n===void 0){discordLogger.debug("Command returned void, skipping response");return}discordLogger.debug("Sage is handling reply:",n);const c=typeof n=="string"?{content:n}:n;e.deferred?await e.editReply(c):await e.reply(c);}catch(o){discordLogger.error(o),printErrorResponse(o,e);}}async function _(e,i){const r=portal.context.get(i);if(!r){discordLogger.error(`No context menu command matching "${i}" was found.`);return}if(!portal.module(r.module).isEnabled){discordLogger.debug(`Tried to execute disabled context menu command from module: ${color.bold(r.module)}`);return}try{for(const o of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(o.plugin?.path??".",o.path))}`);const a=await o.handler.default({payload:[e],record:r});if(a&&a.abort){discordLogger.debug(`Middleware aborted context command: ${color.bold(i)}`);return}}}catch(o){discordLogger.error("Aborting due to middleware error:",o);return}const d=r.handler.config,s=getConfig(),l=getSage(d,s);discordLogger.debug("Sage options:",l);try{if(discordLogger.debug(`Executing context menu handler: ${color.bold(g.join(r.plugin?.path??".",r.path))}`),!r.handler.default)throw `Missing default export function for command: ${color.bold("/"+i)}`;let o;e.isMessageContextMenuCommand()?o=e.targetMessage:e.isUserContextMenuCommand()&&(o=e.targetUser);const a=r.handler.default(e,o),u=[];let n;if(l.defer&&a instanceof Promise){const y=timeout(()=>BUFFER,l.deferBuffer),C=await Promise.race([a,y]);C===BUFFER&&!e.replied?(discordLogger.debug("Sage is deferring async command..."),u.push(a),e.deferred||await e.deferReply({ephemeral:l.ephemeral})):n=C;}if(u.length>0){if(s?.timeouts?.commandDeferral&&u.push(timeout(()=>TIMEOUT,s.timeouts.commandDeferral)),n=await Promise.race(u),n===TIMEOUT)throw new Error("Context menu command timed out")}else a instanceof Promise||(n=a);if(n===void 0){discordLogger.debug("Context menu command returned void, skipping response");return}discordLogger.debug("Sage is handling reply:",n);const c=typeof n=="string"?{content:n}:n;e.deferred?await e.editReply(c):await e.reply(c);}catch(o){discordLogger.error(o),printErrorResponse(o,e);}}async function G(e,i,...r){const d=portal.events.get(i);if(!d?.length)return Promise.resolve();const s=getConfig(),l=i.startsWith("_");await Promise.all(d.map(async o=>{try{if(discordLogger.debug(`Executing event handler: ${color.bold(g.join(o.plugin?.path??".",o.path))}`),!o.handler.default)throw `Missing default export function for event: ${color.bold(i)}`;if(!portal.module(o.module).isEnabled){discordLogger.debug(`Tried to execute disabled event from module: ${color.bold(o.module)}`);return}try{for(const n of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(n.plugin?.path??".",n.path))}`);const c=await n.handler.default({payload:r,record:o});if(c&&c.abort){discordLogger.debug(`Middleware aborted event: ${color.bold(i)}`);return}}}catch(n){discordLogger.error("Aborting due to middleware error:",n);return}const a=o.handler.default(...r,e?.get(o.plugin?.name)?.options);if(!l)return await a;const u=timeout(()=>TIMEOUT,s?.timeouts?.lifecycle||DEFAULT_CONFIG.timeouts.lifecycle);return await Promise.race([a,u])}catch(a){try{const u=e?.get(o.plugin?.name)?.metaOptions??{};let n;a===TIMEOUT?(n=`${i} lifecycle event handler timed out`,discordLogger.warn(n)):o.plugin?i==="_start"&&u.failSafe?(n=`${o.plugin.name} plugin failed to start`,discordLogger.warn(n,a)):(n=`${o.plugin.name} plugin error in event ${i}`,discordLogger.error(n,a)):(n=`Error executing ${i} event handler`,discordLogger.error(n,a)),printErrorResponse(a,r[0],n,o);}catch(u){discordLogger.error("Error handling event error...",u);}}}));}function V(e){return e}function I(e,i){const r={};return i?.forEach(d=>{if(j.includes(d.type))r[d.name]=e.options.get(d.name)?.value;else if(d.type==="attachment")r[d.name]=e.options.get(d.name)?.attachment;else if(d.type==="channel")r[d.name]=e.options.get(d.name)?.channel;else if(d.type==="mention"){const s=e.options.get(d.name);r[d.name]=s?.member??s?.role;}else d.type==="role"?r[d.name]=e.options.get(d.name)?.role:d.type==="user"?r[d.name]=e.options.get(d.name)?.user:d.type==="member"&&(r[d.name]=e.options.get(d.name)?.member);}),r}

export { V as createCommandConfig, B as executeAutocompleteHandler, L as executeCommandHandler, _ as executeContextHandler, G as executeEventHandler, I as extractCommandOptions };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=handlers.js.map