import { color } from './color.js';
import { registerProcessEvents } from './process.js';
import { Client, Events, Collection } from 'discord.js';
import { loadConfig, getConfig } from './config.js';
import { discordLogger } from './constants.js';
import { logger } from './logger.js';
import { loadManifest } from '../cli/utils/manifest.js';
import { env } from './env.js';
import { executeEventHandler, executeCommandHandler, executeAutocompleteHandler, executeContextHandler } from './handlers.js';
import { hasProperties } from '../cli/utils/utils.js';
import { prepareFlashcore } from './flashcore.js';
import E from './portal.js';
import { isMainThread, parentPort } from 'node:worker_threads';

const U={restart:k,start:L,stop:M};let a,f,b;async function L(t){const{client:o,stateLoad:i}=t??{};registerProcessEvents();const[n]=await Promise.all([loadConfig(),loadManifest()]);logger({drain:n?.logger?.drain,enabled:n?.logger?.enabled,level:n?.logger?.level}).debug("Starting Robo..."),i&&(logger.debug("Waiting for state..."),await i);const l=B();if(await prepareFlashcore(),n.experimental?.disableBot!==!0?a=o??new Client(n.clientOptions):logger.debug("Bot is disabled, skipping client setup..."),f=await E.open(),await executeEventHandler(l,"_start",a),n.experimental?.disableBot!==!0){for(const e of f.events.keys()){const m=f.events.get(e).every(c=>c.auto);a.on(e,async(...c)=>{m||discordLogger.event(`Event received: ${color.bold(e)}`),discordLogger.trace("Event args:",c),executeEventHandler(l,e,...c);});}a.on(Events.InteractionCreate,async e=>{if(e.isChatInputCommand()){const m=v(e);discordLogger.event(`Received slash command interaction: ${color.bold("/"+m)}`),discordLogger.trace("Slash command interaction:",e.toJSON()),await executeCommandHandler(e,m);}else if(e.isAutocomplete()){const m=v(e);discordLogger.event(`Received autocomplete interaction for: ${color.bold(e.commandName)}`),discordLogger.trace("Autocomplete interaction:",e.toJSON()),await executeAutocompleteHandler(e,m);}else e.isContextMenuCommand()&&(discordLogger.event(`Received context menu interaction: ${color.bold(e.commandName)}`),discordLogger.trace("Context menu interaction:",e.toJSON()),await executeContextHandler(e,e.commandName));}),await a.login(env.discord.token);}}async function M(t=0){try{await executeEventHandler(b,"_stop",a),a?.destroy(),logger.debug("Stopped Robo at "+new Date().toLocaleString());}finally{isMainThread||(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close()),process.exit(t);}}async function k(){try{await executeEventHandler(b,"_restart",a),a?.destroy(),logger.debug("Restarted Robo at "+new Date().toLocaleString());}finally{isMainThread?process.exit(0):(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close(),process.exit());}}function v(t){const o=[t.commandName];if(hasProperties(t.options,["getSubcommandGroup"]))try{o.push(t.options.getSubcommandGroup());}catch{}if(hasProperties(t.options,["getSubcommand"]))try{o.push(t.options.getSubcommand());}catch{}return o.filter(Boolean).join(" ")}function B(){const t=getConfig(),o=new Collection;if(!t.plugins)return o;for(const i of t.plugins)if(typeof i=="string")o.set(i,{name:i});else if(Array.isArray(i)){const[n,l,e]=i;o.set(n,{name:n,options:l,metaOptions:e});}return o}

export { U as Robo, a as client, f as portal };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=robo.js.map