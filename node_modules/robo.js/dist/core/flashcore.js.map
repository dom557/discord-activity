{"version":3,"sources":["../../src/core/flashcore.ts"],"names":["getConfig","FlashcoreFileAdapter","logger","_adapter","_watchers","Flashcore","key","options","oldValue","callback","value","setValue","resolvedOldValue","newValue","prepareFlashcore","config","Keyv","keyv","error"],"mappings":"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","sourcesContent":["import { getConfig } from './config.js'\nimport { FlashcoreFileAdapter } from './flashcore-fs.js'\nimport { logger } from './logger.js'\nimport type { FlashcoreAdapter } from '../types/index.js'\n\ntype WatcherCallback<V = unknown> = (oldValue: V, newValue: V) => void | Promise<void>\n\n// Store that powers the Flashcore API.\nlet _adapter: FlashcoreAdapter | undefined\n\n// Watchers for listening to changes in the store.\nconst _watchers = new Map<string, Set<WatcherCallback>>()\n\ninterface FlashcoreOptions {\n\tnamespace?: string | Array<string>\n}\n\nexport const Flashcore = {\n\t/**\n\t * Clears all key-value pairs from the store.\n\t *\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tclear: (): Promise<boolean> | Promise<void> | boolean | void => {\n\t\treturn _adapter.clear()\n\t},\n\n\t/**\n\t * Deletes the value associated with a key from the store.\n\t *\n\t * @param {string} key - The key associated with the value to delete.\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tdelete: (key: string, options?: FlashcoreOptions): Promise<boolean> | boolean => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (_watchers.has(key)) {\n\t\t\tconst oldValue = _adapter.get(key)\n\t\t\tif (oldValue instanceof Promise) {\n\t\t\t\t// Return as promise to avoid race condition fetching the old value.\n\t\t\t\t// I believe this is ideal, as promise-based values are likely to be used with async/await.\n\t\t\t\treturn oldValue\n\t\t\t\t\t.then((oldValue) => {\n\t\t\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, undefined))\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => _adapter.delete(key))\n\t\t\t\t\t.catch(() => _adapter.delete(key))\n\t\t\t} else {\n\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, undefined))\n\t\t\t}\n\t\t}\n\n\t\treturn _adapter.delete(key)\n\t},\n\n\t/**\n\t * Gets the value associated with a key.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key associated with the value.\n\t * @returns {Promise<V> | V} - May return a promise you can await or the value directly.\n\t */\n\tget: <V>(key: string, options?: FlashcoreOptions & { default?: unknown }): Promise<V> | V => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\treturn (_adapter.get(key) ?? options?.default) as V\n\t},\n\n\thas: (key: string, options?: FlashcoreOptions): Promise<boolean> | boolean => {\n\t\tif (options?.namespace) {\n\t\t\tkey = `${options.namespace}__${key}`\n\t\t}\n\t\treturn _adapter.has(key)\n\t},\n\n\t/**\n\t * Unregisters a callback from a key, so it will no longer be executed when the key's value changes.\n\t *\n\t * @param {string} key - The key to stop watching.\n\t * @param {WatcherCallback} callback - The callback function to remove from the key's watch list.\n\t * If no callback is provided, all callbacks associated with the key are removed.\n\t */\n\toff: (key: string, callback?: WatcherCallback, options?: FlashcoreOptions) => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (_watchers.has(key) && callback) {\n\t\t\t_watchers.get(key)?.delete(callback)\n\n\t\t\tif (_watchers.get(key)?.size === 0) {\n\t\t\t\t_watchers.delete(key)\n\t\t\t}\n\t\t} else if (_watchers.has(key)) {\n\t\t\t_watchers.delete(key)\n\t\t}\n\t},\n\n\t/**\n\t * Registers a callback to be executed when a specific key's value changes in the store.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key to watch for changes.\n\t * @param {WatcherCallback} callback - The callback function to execute when the key's value changes.\n\t * The callback receives the new and old values as arguments.\n\t */\n\ton: (key: string, callback: WatcherCallback, options?: FlashcoreOptions) => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (!_watchers.has(key)) {\n\t\t\t_watchers.set(key, new Set())\n\t\t}\n\n\t\t_watchers.get(key)?.add(callback)\n\t},\n\n\t/**\n\t * Sets a key-value pair in the store.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key to associate with the value.\n\t * @param {V} value - The value to set.\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tset: <V>(key: string, value: V, options?: FlashcoreOptions): Promise<boolean> | boolean => {\n\t\t// If a namespace is provided, prepend it to the key\n\t\tif (options?.namespace) {\n\t\t\tkey = Array.isArray(options.namespace) ? `${options.namespace.join('/')}__${key}` : `${options.namespace}__${key}`\n\t\t}\n\n\t\tif (_watchers.has(key) || typeof value === 'function') {\n\t\t\t// Fetch the old value only when necessary for minimal overhead\n\t\t\tconst oldValue: unknown = _adapter.get(key)\n\n\t\t\tconst setValue = async (resolvedOldValue: V) => {\n\t\t\t\tlet newValue = value\n\n\t\t\t\t// If value is an updater function, use it to compute the new value based on the old value\n\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\tnewValue = (value as (oldValue: V) => V)(resolvedOldValue as V)\n\t\t\t\t}\n\n\t\t\t\t// Run the watcher callbacks if any are set for this key\n\t\t\t\tif (_watchers.has(key)) {\n\t\t\t\t\t_watchers.get(key).forEach((callback) => callback(resolvedOldValue, newValue))\n\t\t\t\t}\n\n\t\t\t\t// Set the new value in the adapter\n\t\t\t\treturn _adapter.set(key, newValue)\n\t\t\t}\n\n\t\t\t// If the old value is a promise, wait for it to resolve before proceeding\n\t\t\tif (oldValue instanceof Promise) {\n\t\t\t\t// Return as promise to avoid race condition fetching the old value.\n\t\t\t\t// I believe this is ideal, as promise-based values are likely to be used with async/await.\n\t\t\t\treturn oldValue\n\t\t\t\t\t.then(async (resolvedOldValue) => await setValue(resolvedOldValue))\n\t\t\t\t\t.catch(() => _adapter.set(key, value)) // Fallback to set the value directly in case of an error\n\t\t\t} else {\n\t\t\t\treturn setValue(oldValue as V)\n\t\t\t}\n\t\t}\n\n\t\treturn _adapter.set(key, value)\n\t}\n}\n\nexport async function prepareFlashcore() {\n\tconst config = getConfig()\n\n\tif (config.flashcore?.keyv) {\n\t\ttry {\n\t\t\tlogger.debug(`Using Keyv Flashcore adapter`)\n\t\t\tconst Keyv = (await import('keyv')).default\n\t\t\tconst keyv = new Keyv(config.flashcore.keyv)\n\n\t\t\tkeyv.on('error', (error) => {\n\t\t\t\tlogger.error(`Keyv error:`, error)\n\t\t\t})\n\t\t\t_adapter = keyv\n\t\t} catch (error) {\n\t\t\tlogger.error(error)\n\t\t\tthrow new Error('Failed to import or setup the adapter with keyv package.')\n\t\t}\n\t} else {\n\t\t_adapter = new FlashcoreFileAdapter()\n\t\tawait (_adapter as FlashcoreFileAdapter).init()\n\t}\n}\n"]}