import { env } from '../core/env.js';
import { logger } from '../core/logger.js';
import { getRoboPackageJson, packageJson, hasProperties } from '../cli/utils/utils.js';
import { createOAuth, pollOAuth, verifyOAuth } from './oauth.js';
import { createDeployment, updateDeployment, uploadBundle } from './deploy.js';
import { getPodLogs, listPods, startPod, getPodStatus, stopPod, listRobos, getRoboStatus } from './robos.js';
import os from 'node:os';

const RoboPlay = {
  Deploy: {
    create: createDeployment,
    update: updateDeployment,
    upload: uploadBundle
  },
  OAuth: {
    create: createOAuth,
    poll: pollOAuth,
    verify: verifyOAuth
  },
  Pod: {
    getLogs: getPodLogs,
    list: listPods,
    start: startPod,
    status: getPodStatus,
    stop: stopPod
  },
  Robo: {
    list: listRobos,
    status: getRoboStatus
  },
  status: () => request("/status", {
    backoff: false,
    silent: true
  }).then(() => true).catch(() => false)
};
async function request(urlPath, options) {
  const { backoff = true, body, headers, method = "GET", query, raw, retries = 3, silent } = options ?? {};
  let retryCount = 0;
  let queryString = "";
  if (query) {
    const normalizedQuery = {};
    Object.entries(query).forEach(([key, value]) => {
      if (value !== void 0) {
        normalizedQuery[key] = String(value);
      }
    });
    queryString = "?" + new URLSearchParams(normalizedQuery).toString();
  }
  const roboPackageJson = await getRoboPackageJson();
  const extraHeaders = {
    "X-Robo-Project-Description": sanitizeForAscii(roboPackageJson.description ?? ""),
    "X-Robo-Project-Name": sanitizeForAscii(roboPackageJson.name ?? ""),
    "X-Robo-Project-Version": sanitizeForAscii(roboPackageJson.version ?? ""),
    "X-Robo-Version": packageJson.version
  };
  if (env.roboplay.debug) {
    extraHeaders["X-Robo-OS-Arch"] = os.arch();
    extraHeaders["X-Robo-OS-Hostname"] = sanitizeForAscii(os.hostname());
    extraHeaders["X-Robo-OS-Platform"] = os.platform();
    extraHeaders["X-Robo-OS-Name"] = os.type();
    extraHeaders["X-Robo-OS-Release"] = os.release();
  }
  let requestBody;
  if (body instanceof FormData) {
    requestBody = body;
  } else if (body) {
    requestBody = JSON.stringify(body);
    extraHeaders["Content-Type"] = "application/json";
  }
  while (retryCount <= retries) {
    try {
      const response = await fetch(env.roboplay.api + urlPath + queryString, {
        method,
        headers: {
          ...extraHeaders,
          ...headers ?? {}
        },
        body: requestBody
      });
      if (raw) {
        return response;
      }
      const jsonResponse = await response.json();
      if (response.status >= 500) {
        throw new Error(`HTTP Error status code: ${response.status}`);
      }
      return jsonResponse;
    } catch (error) {
      if (retryCount === retries) {
        if (!silent) {
          logger.error(error);
        }
        throw error;
      }
      const delay = backoff ? 2 ** retryCount * 1e3 : 1e3;
      const message = hasProperties(error, ["message"]) ? error.message + " - " : "";
      logger.debug(error);
      if (!silent) {
        logger.warn(`${message}Retrying in ${delay}ms...`);
      }
      await new Promise((r) => setTimeout(r, delay));
      retryCount++;
    }
  }
  throw new Error("Failed to call RoboPlay API");
}
async function requestStream(urlPath, callback) {
  const response = await fetch(env.roboplay.api + urlPath, {
    headers: {
      "Content-Type": "text/event-stream"
    }
  });
  const reader = response.body?.getReader();
  if (!reader) {
    callback(new Error("Failed to get readable stream reader"), null);
    return;
  }
  let buffer = "";
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    buffer += new TextDecoder().decode(value);
    const parts = buffer.split("\n\n");
    buffer = parts.pop();
    for (const part of parts) {
      const message = part.split("\n").reduce((acc, line) => {
        const [key, value2] = line.split(": ");
        return { ...acc, [key]: value2 };
      }, {});
      if (typeof message.data === "string" && message.data.startsWith("{") && message.data.endsWith("}")) {
        callback(null, JSON.parse(message.data));
      }
    }
  }
}
const AsciiRegex = new RegExp(/[^\x00-\x7F]/g);
function sanitizeForAscii(input) {
  return input?.replace(AsciiRegex, "_");
}

export { RoboPlay, request, requestStream };
