import { handlePublicFile } from "../../../.robo/build/core/handler.js";
import { logger } from "../core/logger.js";
import { RoboRequest, applyParams } from "../../../.robo/build/core/robo-request.js";
import { BaseEngine } from "./base.js";
import { createReadStream } from "node:fs";
import url from "node:url";
import { color, composeColors } from "robo.js";
export class FastifyEngine extends BaseEngine {
    async init(options) {
        const { fastify  } = await import("fastify");
        this._server = fastify();
        this._vite = options.vite;
        this._server.removeAllContentTypeParsers();
        this._server.addContentTypeParser('*', (_req, payload, done)=>{
            const chunks = [];
            payload.on('data', (chunk)=>{
                chunks.push(chunk);
            });
            payload.on('end', ()=>{
                done(null, Buffer.concat(chunks));
            });
        });
        this._server.setErrorHandler((error, _request, reply)=>{
            logger.error(error);
            reply.status(500).send({
                ok: false
            });
        });
        this._server.setNotFoundHandler((request, reply)=>{
            logger.debug(color.bold(request.method), request.raw.url);
            if (this._vite) {
                logger.debug(`Forwarding to Vite:`, request.url);
                this._vite.middlewares(request.raw, reply.raw);
                return;
            }
            const run = async ()=>{
                try {
                    const callback = async (filePath, mimeType)=>{
                        await reply.header('Content-Type', mimeType).header('X-Content-Type-Options', 'nosniff').type(mimeType).send(createReadStream(filePath));
                    };
                    const parsedUrl = url.parse(request.url, true);
                    if (await handlePublicFile(parsedUrl, callback)) {
                        return;
                    }
                } catch (error) {
                    if (error instanceof Response) {
                        reply.send(error);
                        return;
                    } else if (error instanceof Error) {
                        logger.error(error);
                        reply.code(500).send(error.message ?? 'Server encountered an error.');
                        return;
                    } else {
                        logger.error(error);
                    }
                }
                reply.status(404).send({
                    message: `Route ${request.method}:${request.url} not found`,
                    error: 'Not Found',
                    statusCode: 404
                });
            };
            run();
        });
    }
    getHttpServer() {
        return this._server?.server;
    }
    isRunning() {
        return this._isRunning;
    }
    registerRoute(path, handler) {
        this._server.route({
            method: [
                'GET',
                'POST',
                'PUT',
                'DELETE',
                'PATCH',
                'OPTIONS',
                'HEAD'
            ],
            url: path,
            handler: async (request, reply)=>{
                // Prepare request and reply wrappers for easier usage
                const requestWrapper = await RoboRequest.from(request.raw, {
                    body: request.body
                });
                applyParams(requestWrapper, request.params);
                const replyWrapper = {
                    raw: reply.raw,
                    hasSent: false,
                    code: function(statusCode) {
                        reply.code(statusCode);
                        return this;
                    },
                    json: function(data) {
                        reply.header('Content-Type', 'application/json').send(JSON.stringify(data));
                        this.hasSent = true;
                        return this;
                    },
                    send: function(data) {
                        if (data instanceof Response) {
                            reply.hijack();
                            if (data.status >= 400) {
                                logger.error(data);
                            }
                            data.headers.forEach(([key, value])=>{
                                reply.header(key, value);
                            });
                            this.raw.statusCode = data.status;
                            data.text().then((text)=>{
                                reply.raw.end(text);
                            });
                        } else {
                            reply.send(data);
                        }
                        this.hasSent = true;
                        return this;
                    },
                    header: function(name, value) {
                        reply.header(name, value);
                        return this;
                    }
                };
                try {
                    logger.debug(color.bold(request.method), request.raw.url);
                    const result = await handler(requestWrapper, replyWrapper);
                    if (!replyWrapper.hasSent && result instanceof Response) {
                        replyWrapper.send(result);
                    } else if (!replyWrapper.hasSent && result) {
                        replyWrapper.code(200).json(result);
                    }
                } catch (error) {
                    if (error instanceof Response) {
                        replyWrapper.send(error);
                    } else if (error instanceof Error) {
                        logger.error(error);
                        replyWrapper.code(500).json({
                            ok: false,
                            errors: Array.isArray(error) ? error.map((e)=>e.message) : [
                                error.message
                            ]
                        });
                    } else {
                        logger.error(error);
                        replyWrapper.code(500).json({
                            ok: false,
                            errors: [
                                'Server encountered an error.'
                            ]
                        });
                    }
                }
            }
        });
    }
    registerWebsocket() {
        logger.warn(`Websockets are not supported in Fastify engine yet.`);
    }
    setupVite(vite) {
        this._vite = vite;
    }
    async start(options) {
        const { port  } = options;
        return new Promise((resolve)=>{
            const run = async ()=>{
                if (this._isRunning) {
                    logger.warn('Fastify server is already up and running. No action taken.');
                    resolve();
                    return;
                }
                // Start server
                this._isRunning = true;
                this._server.listen({
                    port
                }, ()=>{
                    logger.ready(`Fastify server is live at`, composeColors(color.bold, color.blue)(`http://localhost:${port}`));
                    resolve();
                });
            };
            run();
        });
    }
    async stop() {
        const serverPromise = new Promise((resolve)=>{
            if (!this._server) {
                logger.debug(`Fastify server isn't running. Nothing to stop here.`);
                resolve();
                return;
            }
            this._server.close().then(()=>{
                this._isRunning = false;
                logger.debug('Fastify server has been stopped successfully.');
                resolve();
            }).catch((err)=>{
                logger.error(`Error stopping the Fastify server: ${err}`);
            });
        });
        const vitePromise = this._vite?.close();
        await Promise.allSettled([
            serverPromise,
            vitePromise
        ]);
    }
    constructor(...args){
        super(...args);
        this._isRunning = false;
        this._server = null;
        this._vite = null;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3JvYm8uanMvcm9iby5qcy9wYWNrYWdlcy9wbHVnaW4tYXBpL3NyYy9lbmdpbmVzL2Zhc3RpZnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFuZGxlUHVibGljRmlsZSB9IGZyb20gJ34vY29yZS9oYW5kbGVyLmpzJ1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vY29yZS9sb2dnZXIuanMnXG5pbXBvcnQgeyBSb2JvUmVxdWVzdCwgYXBwbHlQYXJhbXMgfSBmcm9tICd+L2NvcmUvcm9iby1yZXF1ZXN0LmpzJ1xuaW1wb3J0IHsgQmFzZUVuZ2luZSB9IGZyb20gJy4vYmFzZS5qcydcbmltcG9ydCB7IGNyZWF0ZVJlYWRTdHJlYW0gfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHVybCBmcm9tICdub2RlOnVybCdcbmltcG9ydCB7IGNvbG9yLCBjb21wb3NlQ29sb3JzIH0gZnJvbSAncm9iby5qcydcbmltcG9ydCB0eXBlIHsgUm9ib1JlcGx5LCBSb3V0ZUhhbmRsZXIgfSBmcm9tICcuLi9jb3JlL3R5cGVzLmpzJ1xuaW1wb3J0IHR5cGUgeyBJbml0T3B0aW9ucywgU3RhcnRPcHRpb25zIH0gZnJvbSAnLi9iYXNlLmpzJ1xuaW1wb3J0IHR5cGUgeyBGYXN0aWZ5SW5zdGFuY2UgfSBmcm9tICdmYXN0aWZ5J1xuaW1wb3J0IHR5cGUgeyBWaXRlRGV2U2VydmVyIH0gZnJvbSAndml0ZSdcblxuZXhwb3J0IGNsYXNzIEZhc3RpZnlFbmdpbmUgZXh0ZW5kcyBCYXNlRW5naW5lIHtcblx0cHJpdmF0ZSBfaXNSdW5uaW5nID0gZmFsc2Vcblx0cHJpdmF0ZSBfc2VydmVyOiBGYXN0aWZ5SW5zdGFuY2UgfCBudWxsID0gbnVsbFxuXHRwcml2YXRlIF92aXRlOiBWaXRlRGV2U2VydmVyIHwgbnVsbCA9IG51bGxcblxuXHRwdWJsaWMgYXN5bmMgaW5pdChvcHRpb25zOiBJbml0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHsgZmFzdGlmeSB9ID0gYXdhaXQgaW1wb3J0KCdmYXN0aWZ5Jylcblx0XHR0aGlzLl9zZXJ2ZXIgPSBmYXN0aWZ5KClcblx0XHR0aGlzLl92aXRlID0gb3B0aW9ucy52aXRlXG5cblx0XHR0aGlzLl9zZXJ2ZXIucmVtb3ZlQWxsQ29udGVudFR5cGVQYXJzZXJzKClcblx0XHR0aGlzLl9zZXJ2ZXIuYWRkQ29udGVudFR5cGVQYXJzZXIoJyonLCAoX3JlcSwgcGF5bG9hZCwgZG9uZSkgPT4ge1xuXHRcdFx0Y29uc3QgY2h1bmtzOiBCdWZmZXJbXSA9IFtdXG5cdFx0XHRwYXlsb2FkLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG5cdFx0XHRcdGNodW5rcy5wdXNoKGNodW5rKVxuXHRcdFx0fSlcblx0XHRcdHBheWxvYWQub24oJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0ZG9uZShudWxsLCBCdWZmZXIuY29uY2F0KGNodW5rcykpXG5cdFx0XHR9KVxuXHRcdH0pXG5cblx0XHR0aGlzLl9zZXJ2ZXIuc2V0RXJyb3JIYW5kbGVyKChlcnJvciwgX3JlcXVlc3QsIHJlcGx5KSA9PiB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoZXJyb3IpXG5cdFx0XHRyZXBseS5zdGF0dXMoNTAwKS5zZW5kKHsgb2s6IGZhbHNlIH0pXG5cdFx0fSlcblxuXHRcdHRoaXMuX3NlcnZlci5zZXROb3RGb3VuZEhhbmRsZXIoKHJlcXVlc3QsIHJlcGx5KSA9PiB7XG5cdFx0XHRsb2dnZXIuZGVidWcoY29sb3IuYm9sZChyZXF1ZXN0Lm1ldGhvZCksIHJlcXVlc3QucmF3LnVybClcblxuXHRcdFx0aWYgKHRoaXMuX3ZpdGUpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBGb3J3YXJkaW5nIHRvIFZpdGU6YCwgcmVxdWVzdC51cmwpXG5cdFx0XHRcdHRoaXMuX3ZpdGUubWlkZGxld2FyZXMocmVxdWVzdC5yYXcsIHJlcGx5LnJhdylcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJ1biA9IGFzeW5jICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGFzeW5jIChmaWxlUGF0aDogc3RyaW5nLCBtaW1lVHlwZTogc3RyaW5nKSA9PiB7XG5cdFx0XHRcdFx0XHRhd2FpdCByZXBseVxuXHRcdFx0XHRcdFx0XHQuaGVhZGVyKCdDb250ZW50LVR5cGUnLCBtaW1lVHlwZSlcblx0XHRcdFx0XHRcdFx0LmhlYWRlcignWC1Db250ZW50LVR5cGUtT3B0aW9ucycsICdub3NuaWZmJylcblx0XHRcdFx0XHRcdFx0LnR5cGUobWltZVR5cGUpXG5cdFx0XHRcdFx0XHRcdC5zZW5kKGNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHBhcnNlZFVybCA9IHVybC5wYXJzZShyZXF1ZXN0LnVybCwgdHJ1ZSlcblx0XHRcdFx0XHRpZiAoYXdhaXQgaGFuZGxlUHVibGljRmlsZShwYXJzZWRVcmwsIGNhbGxiYWNrKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0XHRyZXBseS5zZW5kKGVycm9yKVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoZXJyb3IpXG5cdFx0XHRcdFx0XHRyZXBseS5jb2RlKDUwMCkuc2VuZChlcnJvci5tZXNzYWdlID8/ICdTZXJ2ZXIgZW5jb3VudGVyZWQgYW4gZXJyb3IuJylcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoZXJyb3IpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVwbHlcblx0XHRcdFx0XHQuc3RhdHVzKDQwNClcblx0XHRcdFx0XHQuc2VuZCh7IG1lc3NhZ2U6IGBSb3V0ZSAke3JlcXVlc3QubWV0aG9kfToke3JlcXVlc3QudXJsfSBub3QgZm91bmRgLCBlcnJvcjogJ05vdCBGb3VuZCcsIHN0YXR1c0NvZGU6IDQwNCB9KVxuXHRcdFx0fVxuXHRcdFx0cnVuKClcblx0XHR9KVxuXHR9XG5cblx0cHVibGljIGdldEh0dHBTZXJ2ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlcnZlcj8uc2VydmVyXG5cdH1cblxuXHRwdWJsaWMgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pc1J1bm5pbmdcblx0fVxuXG5cdHB1YmxpYyByZWdpc3RlclJvdXRlKHBhdGg6IHN0cmluZywgaGFuZGxlcjogUm91dGVIYW5kbGVyKTogdm9pZCB7XG5cdFx0dGhpcy5fc2VydmVyLnJvdXRlKHtcblx0XHRcdG1ldGhvZDogWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJywgJ1BBVENIJywgJ09QVElPTlMnLCAnSEVBRCddLFxuXHRcdFx0dXJsOiBwYXRoLFxuXHRcdFx0aGFuZGxlcjogYXN5bmMgKHJlcXVlc3QsIHJlcGx5KSA9PiB7XG5cdFx0XHRcdC8vIFByZXBhcmUgcmVxdWVzdCBhbmQgcmVwbHkgd3JhcHBlcnMgZm9yIGVhc2llciB1c2FnZVxuXHRcdFx0XHRjb25zdCByZXF1ZXN0V3JhcHBlciA9IGF3YWl0IFJvYm9SZXF1ZXN0LmZyb20ocmVxdWVzdC5yYXcsIHsgYm9keTogcmVxdWVzdC5ib2R5IGFzIEJ1ZmZlciB9KVxuXHRcdFx0XHRhcHBseVBhcmFtcyhyZXF1ZXN0V3JhcHBlciwgcmVxdWVzdC5wYXJhbXMgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPilcblx0XHRcdFx0Y29uc3QgcmVwbHlXcmFwcGVyOiBSb2JvUmVwbHkgPSB7XG5cdFx0XHRcdFx0cmF3OiByZXBseS5yYXcsXG5cdFx0XHRcdFx0aGFzU2VudDogZmFsc2UsXG5cdFx0XHRcdFx0Y29kZTogZnVuY3Rpb24gKHN0YXR1c0NvZGU6IG51bWJlcikge1xuXHRcdFx0XHRcdFx0cmVwbHkuY29kZShzdGF0dXNDb2RlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXNcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGpzb246IGZ1bmN0aW9uIChkYXRhOiB1bmtub3duKSB7XG5cdFx0XHRcdFx0XHRyZXBseS5oZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJykuc2VuZChKU09OLnN0cmluZ2lmeShkYXRhKSlcblx0XHRcdFx0XHRcdHRoaXMuaGFzU2VudCA9IHRydWVcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzZW5kOiBmdW5jdGlvbiAoZGF0YTogUmVzcG9uc2UgfCBzdHJpbmcpIHtcblx0XHRcdFx0XHRcdGlmIChkYXRhIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdFx0cmVwbHkuaGlqYWNrKClcblxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5zdGF0dXMgPj0gNDAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0bG9nZ2VyLmVycm9yKGRhdGEpXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlYWRlcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0cmVwbHkuaGVhZGVyKGtleSwgdmFsdWUpXG5cdFx0XHRcdFx0XHRcdH0pXG5cblx0XHRcdFx0XHRcdFx0dGhpcy5yYXcuc3RhdHVzQ29kZSA9IGRhdGEuc3RhdHVzXG5cdFx0XHRcdFx0XHRcdGRhdGEudGV4dCgpLnRoZW4oKHRleHQpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZXBseS5yYXcuZW5kKHRleHQpXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXBseS5zZW5kKGRhdGEpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmhhc1NlbnQgPSB0cnVlXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0aGVhZGVyOiBmdW5jdGlvbiAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG5cdFx0XHRcdFx0XHRyZXBseS5oZWFkZXIobmFtZSwgdmFsdWUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKGNvbG9yLmJvbGQocmVxdWVzdC5tZXRob2QpLCByZXF1ZXN0LnJhdy51cmwpXG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihyZXF1ZXN0V3JhcHBlciwgcmVwbHlXcmFwcGVyKVxuXG5cdFx0XHRcdFx0aWYgKCFyZXBseVdyYXBwZXIuaGFzU2VudCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuXHRcdFx0XHRcdFx0cmVwbHlXcmFwcGVyLnNlbmQocmVzdWx0KVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXJlcGx5V3JhcHBlci5oYXNTZW50ICYmIHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0cmVwbHlXcmFwcGVyLmNvZGUoMjAwKS5qc29uKHJlc3VsdClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdHJlcGx5V3JhcHBlci5zZW5kKGVycm9yKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRcdFx0bG9nZ2VyLmVycm9yKGVycm9yKVxuXHRcdFx0XHRcdFx0cmVwbHlXcmFwcGVyLmNvZGUoNTAwKS5qc29uKHtcblx0XHRcdFx0XHRcdFx0b2s6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRlcnJvcnM6IEFycmF5LmlzQXJyYXkoZXJyb3IpID8gZXJyb3IubWFwKChlKSA9PiBlLm1lc3NhZ2UpIDogW2Vycm9yLm1lc3NhZ2VdXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoZXJyb3IpXG5cdFx0XHRcdFx0XHRyZXBseVdyYXBwZXIuY29kZSg1MDApLmpzb24oe1xuXHRcdFx0XHRcdFx0XHRvazogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGVycm9yczogWydTZXJ2ZXIgZW5jb3VudGVyZWQgYW4gZXJyb3IuJ11cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0fVxuXG5cdHB1YmxpYyByZWdpc3RlcldlYnNvY2tldCgpOiB2b2lkIHtcblx0XHRsb2dnZXIud2FybihgV2Vic29ja2V0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiBGYXN0aWZ5IGVuZ2luZSB5ZXQuYClcblx0fVxuXG5cdHB1YmxpYyBzZXR1cFZpdGUodml0ZTogVml0ZURldlNlcnZlcikge1xuXHRcdHRoaXMuX3ZpdGUgPSB2aXRlXG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgc3RhcnQob3B0aW9uczogU3RhcnRPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgeyBwb3J0IH0gPSBvcHRpb25zXG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdGNvbnN0IHJ1biA9IGFzeW5jICgpID0+IHtcblx0XHRcdFx0aWYgKHRoaXMuX2lzUnVubmluZykge1xuXHRcdFx0XHRcdGxvZ2dlci53YXJuKCdGYXN0aWZ5IHNlcnZlciBpcyBhbHJlYWR5IHVwIGFuZCBydW5uaW5nLiBObyBhY3Rpb24gdGFrZW4uJylcblx0XHRcdFx0XHRyZXNvbHZlKClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN0YXJ0IHNlcnZlclxuXHRcdFx0XHR0aGlzLl9pc1J1bm5pbmcgPSB0cnVlXG5cdFx0XHRcdHRoaXMuX3NlcnZlci5saXN0ZW4oeyBwb3J0IH0sICgpID0+IHtcblx0XHRcdFx0XHRsb2dnZXIucmVhZHkoYEZhc3RpZnkgc2VydmVyIGlzIGxpdmUgYXRgLCBjb21wb3NlQ29sb3JzKGNvbG9yLmJvbGQsIGNvbG9yLmJsdWUpKGBodHRwOi8vbG9jYWxob3N0OiR7cG9ydH1gKSlcblx0XHRcdFx0XHRyZXNvbHZlKClcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdHJ1bigpXG5cdFx0fSlcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBzdG9wKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHNlcnZlclByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLl9zZXJ2ZXIpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBGYXN0aWZ5IHNlcnZlciBpc24ndCBydW5uaW5nLiBOb3RoaW5nIHRvIHN0b3AgaGVyZS5gKVxuXHRcdFx0XHRyZXNvbHZlKClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NlcnZlclxuXHRcdFx0XHQuY2xvc2UoKVxuXHRcdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5faXNSdW5uaW5nID0gZmFsc2Vcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoJ0Zhc3RpZnkgc2VydmVyIGhhcyBiZWVuIHN0b3BwZWQgc3VjY2Vzc2Z1bGx5LicpXG5cdFx0XHRcdFx0cmVzb2x2ZSgpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKGBFcnJvciBzdG9wcGluZyB0aGUgRmFzdGlmeSBzZXJ2ZXI6ICR7ZXJyfWApXG5cdFx0XHRcdH0pXG5cdFx0fSlcblx0XHRjb25zdCB2aXRlUHJvbWlzZSA9IHRoaXMuX3ZpdGU/LmNsb3NlKClcblxuXHRcdGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc2VydmVyUHJvbWlzZSwgdml0ZVByb21pc2VdKVxuXHR9XG59XG4iXSwibmFtZXMiOlsiaGFuZGxlUHVibGljRmlsZSIsImxvZ2dlciIsIlJvYm9SZXF1ZXN0IiwiYXBwbHlQYXJhbXMiLCJCYXNlRW5naW5lIiwiY3JlYXRlUmVhZFN0cmVhbSIsInVybCIsImNvbG9yIiwiY29tcG9zZUNvbG9ycyIsIkZhc3RpZnlFbmdpbmUiLCJpbml0Iiwib3B0aW9ucyIsImZhc3RpZnkiLCJfc2VydmVyIiwiX3ZpdGUiLCJ2aXRlIiwicmVtb3ZlQWxsQ29udGVudFR5cGVQYXJzZXJzIiwiYWRkQ29udGVudFR5cGVQYXJzZXIiLCJfcmVxIiwicGF5bG9hZCIsImRvbmUiLCJjaHVua3MiLCJvbiIsImNodW5rIiwicHVzaCIsIkJ1ZmZlciIsImNvbmNhdCIsInNldEVycm9ySGFuZGxlciIsImVycm9yIiwiX3JlcXVlc3QiLCJyZXBseSIsInN0YXR1cyIsInNlbmQiLCJvayIsInNldE5vdEZvdW5kSGFuZGxlciIsInJlcXVlc3QiLCJkZWJ1ZyIsImJvbGQiLCJtZXRob2QiLCJyYXciLCJtaWRkbGV3YXJlcyIsInJ1biIsImNhbGxiYWNrIiwiZmlsZVBhdGgiLCJtaW1lVHlwZSIsImhlYWRlciIsInR5cGUiLCJwYXJzZWRVcmwiLCJwYXJzZSIsIlJlc3BvbnNlIiwiRXJyb3IiLCJjb2RlIiwibWVzc2FnZSIsInN0YXR1c0NvZGUiLCJnZXRIdHRwU2VydmVyIiwic2VydmVyIiwiaXNSdW5uaW5nIiwiX2lzUnVubmluZyIsInJlZ2lzdGVyUm91dGUiLCJwYXRoIiwiaGFuZGxlciIsInJvdXRlIiwicmVxdWVzdFdyYXBwZXIiLCJmcm9tIiwiYm9keSIsInBhcmFtcyIsInJlcGx5V3JhcHBlciIsImhhc1NlbnQiLCJqc29uIiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoaWphY2siLCJoZWFkZXJzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwidGV4dCIsInRoZW4iLCJlbmQiLCJuYW1lIiwicmVzdWx0IiwiZXJyb3JzIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZSIsInJlZ2lzdGVyV2Vic29ja2V0Iiwid2FybiIsInNldHVwVml0ZSIsInN0YXJ0IiwicG9ydCIsIlByb21pc2UiLCJyZXNvbHZlIiwibGlzdGVuIiwicmVhZHkiLCJibHVlIiwic3RvcCIsInNlcnZlclByb21pc2UiLCJjbG9zZSIsImNhdGNoIiwiZXJyIiwidml0ZVByb21pc2UiLCJhbGxTZXR0bGVkIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxnQkFBZ0IsUUFBUSx1Q0FBbUI7QUFDcEQsU0FBU0MsTUFBTSxRQUFRLG9CQUFtQjtBQUMxQyxTQUFTQyxXQUFXLEVBQUVDLFdBQVcsUUFBUSw0Q0FBd0I7QUFDakUsU0FBU0MsVUFBVSxRQUFRLFlBQVc7QUFDdEMsU0FBU0MsZ0JBQWdCLFFBQVEsVUFBUztBQUMxQyxPQUFPQyxTQUFTLFdBQVU7QUFDMUIsU0FBU0MsS0FBSyxFQUFFQyxhQUFhLFFBQVEsVUFBUztBQU05QyxPQUFPLE1BQU1DLHNCQUFzQkw7SUFLbEMsTUFBYU0sS0FBS0MsT0FBb0IsRUFBaUI7UUFDdEQsTUFBTSxFQUFFQyxRQUFPLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQztRQUNqQyxJQUFJLENBQUNDLE9BQU8sR0FBR0Q7UUFDZixJQUFJLENBQUNFLEtBQUssR0FBR0gsUUFBUUksSUFBSTtRQUV6QixJQUFJLENBQUNGLE9BQU8sQ0FBQ0csMkJBQTJCO1FBQ3hDLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxvQkFBb0IsQ0FBQyxLQUFLLENBQUNDLE1BQU1DLFNBQVNDLE9BQVM7WUFDL0QsTUFBTUMsU0FBbUIsRUFBRTtZQUMzQkYsUUFBUUcsRUFBRSxDQUFDLFFBQVEsQ0FBQ0MsUUFBVTtnQkFDN0JGLE9BQU9HLElBQUksQ0FBQ0Q7WUFDYjtZQUNBSixRQUFRRyxFQUFFLENBQUMsT0FBTyxJQUFNO2dCQUN2QkYsS0FBSyxJQUFJLEVBQUVLLE9BQU9DLE1BQU0sQ0FBQ0w7WUFDMUI7UUFDRDtRQUVBLElBQUksQ0FBQ1IsT0FBTyxDQUFDYyxlQUFlLENBQUMsQ0FBQ0MsT0FBT0MsVUFBVUMsUUFBVTtZQUN4RDdCLE9BQU8yQixL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